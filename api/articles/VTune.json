{"title":"Intel VTune Profiler實作紀錄","uid":"f6fb998cdf8b4b8d8fe38e630943d18b","slug":"VTune","date":"2025-09-24T05:18:12.000Z","updated":"2025-10-06T08:16:32.506Z","comments":true,"path":"api/articles/VTune.json","keywords":null,"cover":"https://i.pinimg.com/736x/a9/90/98/a99098763176f685d89453c3ae18bb34.jpg","content":"<p>最近在研究 Nonogram 的過程中，有了幾項有趣的發現：在執行系上高建壹學長撰寫的邏輯規則程式時，我的電腦不僅執行時間縮短了約 30%（應該是硬體效能差異），連 DFS 的呼叫次數也明顯減少。老師因此建議我使用 Profiling 工具VTune，檢測程式在不同階段的效能瓶頸，確認到底是哪個部分造成差異</p>\n<h2 id=\"工具簡介\"><a href=\"#工具簡介\" class=\"headerlink\" title=\"工具簡介\"></a>工具簡介</h2><p>Vtune是Intel出的Profiling工具，可以評估程式效能瓶頸，支援多種語言&#x2F;框架，包含c&#x2F;c++、java、python等，基本上主流的都可以，作業系統則支援Windows、Linux主流版本，最重要的是它有GUI圖形介面可以使用ㄛ!</p>\n<h3 id=\"主要功能\"><a href=\"#主要功能\" class=\"headerlink\" title=\"主要功能\"></a>主要功能</h3><ul>\n<li>CPU&#x2F;演算法耗時分析(尋找Hotspots)<ul>\n<li>自動統計程式中最耗時的函式、程式碼區塊或迴圈</li>\n<li>可檢視call stack(呼叫堆疊)與flame graph，幫助快速鎖定瓶頸</li>\n</ul>\n</li>\n<li>記憶體&#x2F;快取分析(Memory access)<ul>\n<li>計算cache命中率、記憶體頻寬使用率</li>\n<li>協助找出因cache miss或資料移動造成的延遲</li>\n</ul>\n</li>\n<li>系統分析<ul>\n<li>可針對特定功能、進程、時間段進行過濾分析</li>\n<li>支援CPU、GPU、FPGA與I&#x2F;O效能監測</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"環境配置與安裝\"><a href=\"#環境配置與安裝\" class=\"headerlink\" title=\"環境配置與安裝\"></a>環境配置與安裝</h2><h3 id=\"step-1：安裝intel-oneAPI\"><a href=\"#step-1：安裝intel-oneAPI\" class=\"headerlink\" title=\"step 1：安裝intel oneAPI\"></a>step 1：安裝intel oneAPI</h3><p><a href=\"https://www.intel.com/content/www/us/en/developer/tools/oneapi/base-toolkit-download.html\">Get the Intel® oneAPI Base Toolkit</a><br>VTune包含在oneAPI套件中，進到頁面選擇作業系統，還有一個選項是Offline&#x2F;Online installer，翻了網路上的文章好像都沒有說到這塊，問了一下AI，差別好像是在Online安裝時需要連線到Intel伺服器，優點是檔案比較小，因為可以客製化單獨挑選想要下載的元件；Offline的就不需網路，但檔案就大很多(因為他全部套件整包都包含在裡面)，</p>\n<h4 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h4><p>前往網站獲取下載指令，可以自行選擇安裝方式<br>接著就能用下面指令打開offline installer的介面了(實際指令看下載頁面提供的，可能會依版本號不太一樣)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://registrationcenter-download.intel.com/akdlm/IRC_NAS/3b7a16b3-a7b0-460f-be16-de0d64fa6b1e/intel-oneapi-base-toolkit-2025.2.1.44_offline.sh</span><br><span class=\"line\">sh intel-oneapi-base-toolkit-2025.2.1.44_offline.sh</span><br></pre></td></tr></table></figure>\n<p>VTune使用的詳細指令可以看<a href=\"https://www.intel.com/content/www/us/en/docs/vtune-profiler/user-guide/2024-2/command-syntax.html\">VTune command line Syntax</a></p>\n<h4 id=\"Windows\"><a href=\"#Windows\" class=\"headerlink\" title=\"Windows\"></a>Windows</h4><p>我這邊選擇的是Online<br><img src=\"/../imgs/image1.png\" alt=\"image\"></p>\n<p>下載好打開VTune Profiler，一進去他會導覽你去Help Tour，大概對整個的使用方法用一個範例簡單介紹，點<code>New Project</code>可以開始新增專案<br><img src=\"/../imgs/image2.png\" alt=\"image\"></p>\n<p>建立之後開始指定要分析的程式</p>\n<ul>\n<li>Application：要分析的程式</li>\n<li>Application parameters：執行時要加的命令列參數，不一定要</li>\n<li>Working directory：指定程式執行時的工作目錄，像我這邊程式執行時需要餵txt給他，所以就指定根目錄<br><img src=\"/../imgs/image3.png\" alt=\"image\"></li>\n</ul>\n<p>按執行後VTune會產出性能快照，裡面包含Analysis tree，可以選擇接下來要詳細測試的類型，在這裡也可以觀察出最突出的效能瓶頸，會用紅色標註起來(像Hotspots圖標一樣)<br><img src=\"/../imgs/image4.png\" alt=\"image\"></p>\n<p>這邊遇到一個問題，在執行Hotspots分析時出現下面錯誤訊息，說是找不到sepdrv driver，但我檢查過是有安裝的，後來發現得用<em><strong>系統管理員</strong></em>身分打開VTune，就解決囉~<br><img src=\"/../imgs/image5.png\" alt=\"image\"></p>\n<h3 id=\"step-2：開始效能分析\"><a href=\"#step-2：開始效能分析\" class=\"headerlink\" title=\"step 2：開始效能分析\"></a>step 2：開始效能分析</h3><p>VTune有好幾種效能分析的方式：</p>\n<ul>\n<li>直連VTune啟動分析：打開VTune GUI，指定要分析的程式，或 在程式已經在跑的情況下，attach到該程式的進程，開始收集資料<br>我一開始最直覺的想嘗試這個做法，網路上大多也是這樣，有興趣的人可以看一下我的研究過程，總之後來試到覺得太沒效率就放棄了嗚嗚</li>\n<li>先用 perf 工具收集，再匯入 VTune：先使用 Linux 的 perf（一個系統級效能分析工具）在命令列收集程式執行的效能事件與統計數據，生成報告檔（如 perf.data），接著打開 VTune，把這些檔案匯入，利用 GUI 做後續分析</li>\n</ul>\n<p>我這邊是用Intel編譯器執行VTune分析，最後再匯入，Windows GUI視覺化</p>\n<p>首先先載入VTune環境變數，如果不知道<code>setvars.sh</code>在哪可以先用指令找(通常在家目錄底下<code>intel/oneapi/setvars.sh</code>)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find ~/intel -name setvars.sh 2&gt;/dev/null</span><br></pre></td></tr></table></figure>\n<p>載入環境變數</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source &#123;你的路徑&#125;/intel/oneapi/setvars.sh</span><br></pre></td></tr></table></figure>\n<p>可以用<code>vtune -help</code>測試是否載入成功</p>\n<p>接下來可以開始執行要分析的程式，注意程式在編譯時一定要帶<code>-g</code>才能帶debug info!!!<br>開始分析指令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vtune -collect <span class=\"variable\">$COLLECTION_TYPE</span> -r <span class=\"variable\">$RESULT_DIR</span> <span class=\"variable\">$APPLICATION</span></span><br><span class=\"line\"><span class=\"variable\">$APPLICATION_PARAMETERS</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>$COLLECTION_TYPE：分析類型 (hotspots、memory-access、uarch-exploration 等)</li>\n</ul>\n<p>分析完會打包在剛剛指定的資料夾裡，如果你是連遠端機器可以用scp把資料傳輸回本地端，我是用wsl所以沒有這個問題</p>\n<p>點左側選單的資料夾載入剛剛的<code>.vtune</code>檔就可以開始看分析了~<br><img src=\"/../imgs/image7.png\" alt=\"image\"></p>\n<h2 id=\"try-erorrrrrrrrrrrr-紀錄\"><a href=\"#try-erorrrrrrrrrrrr-紀錄\" class=\"headerlink\" title=\"try &amp; erorrrrrrrrrrrr 紀錄\"></a>try &amp; erorrrrrrrrrrrr 紀錄</h2><p>開始執行後遇到一個大問題：<code>Cannot locate debugging information</code></p>\n<p><img src=\"/../imgs/image6.png\" alt=\"image\"></p>\n<p>其實這樣也能正常執行，只是看不到詳細個別的function，剛開始我以為又是哪個driver沒有安裝好，查下發現以為是因為VTune得接收PDB符號(這個通常用於debug)才能將對應的符號對應到編譯程式中的標示符和指令，還因此走了一大段彎路想盡辦法產生<code>.pdb</code>，後來又看到這篇發問，完全就是我遇到的問題<br><a href=\"https://community.intel.com/t5/Analyzers/VTune-does-not-show-source-file-even-with-debugging-info-enabled/m-p/1311678#M21281\">VTune does not show source file even with debugging info enabled</a></p>\n<p>沒想到在產生<code>.pdb</code>這個步驟我又大大的卡關了<br>首先根據Intel doc有提供產生pdb的流程，但是是在Visual Studio IDE環境下(到現在我才知道原來這跟vs code不一樣)，vs code得手動在編譯時設定選項，而且得改成微軟家自己的MSVC編譯器，因此我就將原本的Makefile改成以下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Compiler settings</span><br><span class=\"line\">CC = cl</span><br><span class=\"line\">CXXFLAGS = /O2 /Zi /EHsc /I$(INCdir)</span><br><span class=\"line\">LDFLAGS = /DEBUG</span><br><span class=\"line\">INCdir = include</span><br></pre></td></tr></table></figure>\n<p>然後就開心的在CMD中make，卻又發現以下問題</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process_begin: CreateProcess(NULL, cl /O2 /Zi /EHsc /Iinclude /c src/board.cpp /Foobj/board.obj, ...) failed.</span><br><span class=\"line\">make (e=2): make: *** [makefile:36: obj/board.obj] Error 2</span><br></pre></td></tr></table></figure>\n<p>AI說這是因為<code>cl.exe</code> 是 MSVC 編譯器，只存在於 Visual Studio &#x2F; Build Tools 安裝的 Developer Command Prompt 或 Native Tools Command Prompt，普通 shell 找不到路徑，所以 Make 無法執行 cl<br>上網看了很多的資訊都是教如何在visual studio中安裝，或是資訊太久以前，後來發現visual studio code官方是有doc的，跟著做了一次終於可以了(淚目<br><a href=\"https://code.visualstudio.com/docs/cpp/config-msvc\">Configure VS Code for Microsoft C++</a></p>\n<h2 id=\"開始分析\"><a href=\"#開始分析\" class=\"headerlink\" title=\"開始分析\"></a>開始分析</h2><p>這邊請AI幫我整理了一各個功能的用途</p>\n<table>\n<thead>\n<tr>\n<th>名稱</th>\n<th>中文說明</th>\n<th>重點用途</th>\n<th>觀察方向</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Bottom-up</strong></td>\n<td>自下而上分析</td>\n<td>找出「最耗 CPU 的函式」與它們被誰呼叫，顯示每個函式的「Self Time」和「被誰呼叫」</td>\n<td>🔎 從最底層執行單元往上看「誰造成它被呼叫」</td>\n</tr>\n<tr>\n<td><strong>Caller&#x2F;Callee</strong></td>\n<td>呼叫者&#x2F;被呼叫者關係圖</td>\n<td>看函式之間的呼叫關係與時間分配</td>\n<td>🔄 橫向觀察呼叫關係（誰呼叫誰、誰花最多時間）</td>\n</tr>\n<tr>\n<td><strong>Top-down Tree</strong></td>\n<td>自上而下分析</td>\n<td>看「哪條邏輯路徑」最耗時間，時間是「Inclusive Time（包含所有子呼叫）」</td>\n<td>🌲 從 main() 一路往下展開分析哪裡慢</td>\n</tr>\n<tr>\n<td><strong>Flame Graph</strong></td>\n<td>火焰圖視覺化</td>\n<td>以顏色與長度表示 CPU time（越寬代表越慢），每一層是呼叫堆疊</td>\n<td>🔥 快速直覺找出最熱函式</td>\n</tr>\n<tr>\n<td><strong>Source View</strong></td>\n<td>原始碼檢視</td>\n<td>精確看到哪一行程式碼最耗 CPU</td>\n<td>🧩 找出 bottleneck 行號（結合符號與編譯資訊）</td>\n</tr>\n</tbody></table>\n<p>兩個比較重要的差別</p>\n<ul>\n<li>Bottom-up：想找出「哪個函式最值得優化」</li>\n<li>Top-down Tree：分析「程式流程中哪個階段最慢」</li>\n</ul>\n<p>接著開始分析我的程式，在<code>Summary</code>裡可以看到<em>RLmost</em>是最久CPU time的，所以就先從這裡開始下手<br><img src=\"https://hackmd.io/_uploads/HJ-jQkZTex.png\" alt=\"image\"></p>\n<h3 id=\"Bottom-up\"><a href=\"#Bottom-up\" class=\"headerlink\" title=\"Bottom-up\"></a>Bottom-up</h3><p>進到<code>Bottom-up</code>，可以看到<em>RLmost</em>的call stack，這邊有一個地方我想了很久才搞懂，一開始我以為是顯示total CPU time，也就是執行到該函式時總花費時間，但怎麼看都不合理，因為這樣應該是最高層的caller(main)會最久，但我又想不通如果是self time(函式本身花掉的時間)，為何前面的caller時間加起來剛好是底層<em>RLmost</em>的時間(〒︿〒)<br>還好AI幫我解惑了，其實確實是self time，只是上層caller的時間只是顯示「呼叫這個底層函式時花的時間」，也就是它顯示的是：「這個底層函式的時間，有哪些上層呼叫路徑造成的」</p>\n<p>換句話說：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>這 161 秒的 CPU time 是 <strong>RLmost 自己執行花掉的時間</strong>，<br>而不是上層函式的時間加起來。</p></blockquote>\n<p><img src=\"https://hackmd.io/_uploads/Byzp8JZTgg.png\" alt=\"image\"></p>\n<h3 id=\"Source\"><a href=\"#Source\" class=\"headerlink\" title=\"Source\"></a>Source</h3><p>接著看原始碼，<code>Assembly grouping</code>有三種選項，因為一個函式（function）通常會編譯成許多指令與<strong>基本區塊（basic block）</strong>，所以可以選擇「以哪個粒度」來統計與顯示 CPU 使用情況<br><img src=\"https://hackmd.io/_uploads/BkzQWeWaxx.png\" alt=\"image\"></p>\n<ul>\n<li><p>Address：最細的層級。</p>\n<ul>\n<li>每個 CPU 指令的地址都單獨顯示一列。</li>\n<li>可以看到確切哪個指令最耗時（例如 mov eax, [rbx+4]）。</li>\n<li>適合：想追蹤單條機器指令或 pipeline bottleneck 時使用。</li>\n<li>缺點：資料很多，難以閱讀。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>✅ 類似「逐條指令 profiling」。</p></blockquote>\n</li>\n<li><p>Basic Block &#x2F; Address：中間層級（通常最常用）。</p>\n<ul>\n<li>將多條連續的、無跳躍（no branch） 的指令組成一個 Basic Block（基本區塊）。</li>\n<li>你會看到每個基本區塊的總時間與區塊內指令的細部。</li>\n<li>適合：追蹤迴圈、分支內哪一塊程式最慢，但不需要看到所有指令。<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>✅ 類似「以控制流程為單位」的彙編統計。</p></blockquote>\n</li>\n</ul>\n</li>\n<li><p>Function Range &#x2F; Basic Block &#x2F; Address：階層式顯示：函式 → 基本區塊 → 指令。</p>\n<ul>\n<li>最上層：整個函式（例如 RLmost）。</li>\n<li>展開後：各個 basic block。</li>\n<li>再展開：每個指令（address）。</li>\n<li>適合：要從函式級別一路 drill down 到指令級別分析時使用。<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>可快速定位「哪個函式→哪個區塊→哪條指令」最耗 CPU。<br>✅ 類似「函式樹狀 + 基本區塊細節」的整合視圖。<br>📈 通常建議用這個模式來定位 哪一行 C++ 原始碼 對應到哪個彙編區塊最慢。</p></blockquote>\n</li>\n</ul>\n</li>\n</ul>\n","feature":true,"text":"最近在研究 Nonogram 的過程中，有了幾項有趣的發現：在執行系上高建壹學長撰寫的邏輯規則程式時，我的電腦不僅執行時間縮短了約 30%（應該是硬體效能差異）...","permalink":"/post/VTune","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"開發紀錄","slug":"開發紀錄","count":1,"path":"api/categories/開發紀錄.json"}],"tags":[{"name":"VTune","slug":"VTune","count":1,"path":"api/tags/VTune.json"},{"name":"Profiling","slug":"Profiling","count":1,"path":"api/tags/Profiling.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E5%85%B7%E7%B0%A1%E4%BB%8B\"><span class=\"toc-text\">工具簡介</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">主要功能</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%92%B0%E5%A2%83%E9%85%8D%E7%BD%AE%E8%88%87%E5%AE%89%E8%A3%9D\"><span class=\"toc-text\">環境配置與安裝</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#step-1%EF%BC%9A%E5%AE%89%E8%A3%9Dintel-oneAPI\"><span class=\"toc-text\">step 1：安裝intel oneAPI</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Linux\"><span class=\"toc-text\">Linux</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Windows\"><span class=\"toc-text\">Windows</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#step-2%EF%BC%9A%E9%96%8B%E5%A7%8B%E6%95%88%E8%83%BD%E5%88%86%E6%9E%90\"><span class=\"toc-text\">step 2：開始效能分析</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#try-erorrrrrrrrrrrr-%E7%B4%80%E9%8C%84\"><span class=\"toc-text\">try &amp; erorrrrrrrrrrrr 紀錄</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%96%8B%E5%A7%8B%E5%88%86%E6%9E%90\"><span class=\"toc-text\">開始分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Bottom-up\"><span class=\"toc-text\">Bottom-up</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Source\"><span class=\"toc-text\">Source</span></a></li></ol></li></ol>","author":{"name":"三三","slug":"blog-author","avatar":"https://i.imgur.com/zzSYOPK.jpg","link":"/","description":"一個努力學習技術的小小資工人","socials":{"github":"https://github.com/Sandrala0413","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"Docker 新手初探筆記","uid":"bc9344032968b466e3512767cf2bb0ea","slug":"docker-introduction","date":"2025-05-22T12:11:12.000Z","updated":"2025-09-24T20:28:33.621Z","comments":true,"path":"api/articles/docker-introduction.json","keywords":null,"cover":"https://i.pinimg.com/736x/25/7b/01/257b015a28b4b590c8a690764c914976.jpg","text":"以前在學 Docker 時整理的筆記~之後再慢慢整理一些 Dockerfile、k8s 之類的放上來(๑•̀ㅁ•́๑)✧ Container v.s. VM為了增加...","permalink":"/post/docker-introduction","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"研究筆記","slug":"研究筆記","count":1,"path":"api/categories/研究筆記.json"}],"tags":[{"name":"Docker","slug":"Docker","count":1,"path":"api/tags/Docker.json"}],"author":{"name":"三三","slug":"blog-author","avatar":"https://i.imgur.com/zzSYOPK.jpg","link":"/","description":"一個努力學習技術的小小資工人","socials":{"github":"https://github.com/Sandrala0413","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}