<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://sandrala0413.git/atom.xml" rel="self"/>
  
  <link href="https://sandrala0413.git/"/>
  <updated>2025-10-06T08:16:32.506Z</updated>
  <id>https://sandrala0413.git/</id>
  
  <author>
    <name>Sandrala Tsai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Intel VTune Profiler實作紀錄</title>
    <link href="https://sandrala0413.git/post/VTune.html"/>
    <id>https://sandrala0413.git/post/VTune.html</id>
    <published>2025-09-24T05:18:12.000Z</published>
    <updated>2025-10-06T08:16:32.506Z</updated>
    
    <content type="html"><![CDATA[<p>最近在研究 Nonogram 的過程中，有了幾項有趣的發現：在執行系上高建壹學長撰寫的邏輯規則程式時，我的電腦不僅執行時間縮短了約 30%（應該是硬體效能差異），連 DFS 的呼叫次數也明顯減少。老師因此建議我使用 Profiling 工具VTune，檢測程式在不同階段的效能瓶頸，確認到底是哪個部分造成差異</p><h2 id="工具簡介"><a href="#工具簡介" class="headerlink" title="工具簡介"></a>工具簡介</h2><p>Vtune是Intel出的Profiling工具，可以評估程式效能瓶頸，支援多種語言&#x2F;框架，包含c&#x2F;c++、java、python等，基本上主流的都可以，作業系統則支援Windows、Linux主流版本，最重要的是它有GUI圖形介面可以使用ㄛ!</p><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ul><li>CPU&#x2F;演算法耗時分析(尋找Hotspots)<ul><li>自動統計程式中最耗時的函式、程式碼區塊或迴圈</li><li>可檢視call stack(呼叫堆疊)與flame graph，幫助快速鎖定瓶頸</li></ul></li><li>記憶體&#x2F;快取分析(Memory access)<ul><li>計算cache命中率、記憶體頻寬使用率</li><li>協助找出因cache miss或資料移動造成的延遲</li></ul></li><li>系統分析<ul><li>可針對特定功能、進程、時間段進行過濾分析</li><li>支援CPU、GPU、FPGA與I&#x2F;O效能監測</li></ul></li></ul><h2 id="環境配置與安裝"><a href="#環境配置與安裝" class="headerlink" title="環境配置與安裝"></a>環境配置與安裝</h2><h3 id="step-1：安裝intel-oneAPI"><a href="#step-1：安裝intel-oneAPI" class="headerlink" title="step 1：安裝intel oneAPI"></a>step 1：安裝intel oneAPI</h3><p><a href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/base-toolkit-download.html">Get the Intel® oneAPI Base Toolkit</a><br>VTune包含在oneAPI套件中，進到頁面選擇作業系統，還有一個選項是Offline&#x2F;Online installer，翻了網路上的文章好像都沒有說到這塊，問了一下AI，差別好像是在Online安裝時需要連線到Intel伺服器，優點是檔案比較小，因為可以客製化單獨挑選想要下載的元件；Offline的就不需網路，但檔案就大很多(因為他全部套件整包都包含在裡面)，</p><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>前往網站獲取下載指令，可以自行選擇安裝方式<br>接著就能用下面指令打開offline installer的介面了(實際指令看下載頁面提供的，可能會依版本號不太一樣)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://registrationcenter-download.intel.com/akdlm/IRC_NAS/3b7a16b3-a7b0-460f-be16-de0d64fa6b1e/intel-oneapi-base-toolkit-2025.2.1.44_offline.sh</span><br><span class="line">sh intel-oneapi-base-toolkit-2025.2.1.44_offline.sh</span><br></pre></td></tr></table></figure><p>VTune使用的詳細指令可以看<a href="https://www.intel.com/content/www/us/en/docs/vtune-profiler/user-guide/2024-2/command-syntax.html">VTune command line Syntax</a></p><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>我這邊選擇的是Online<br><img src="/../imgs/image1.png" alt="image"></p><p>下載好打開VTune Profiler，一進去他會導覽你去Help Tour，大概對整個的使用方法用一個範例簡單介紹，點<code>New Project</code>可以開始新增專案<br><img src="/../imgs/image2.png" alt="image"></p><p>建立之後開始指定要分析的程式</p><ul><li>Application：要分析的程式</li><li>Application parameters：執行時要加的命令列參數，不一定要</li><li>Working directory：指定程式執行時的工作目錄，像我這邊程式執行時需要餵txt給他，所以就指定根目錄<br><img src="/../imgs/image3.png" alt="image"></li></ul><p>按執行後VTune會產出性能快照，裡面包含Analysis tree，可以選擇接下來要詳細測試的類型，在這裡也可以觀察出最突出的效能瓶頸，會用紅色標註起來(像Hotspots圖標一樣)<br><img src="/../imgs/image4.png" alt="image"></p><p>這邊遇到一個問題，在執行Hotspots分析時出現下面錯誤訊息，說是找不到sepdrv driver，但我檢查過是有安裝的，後來發現得用<em><strong>系統管理員</strong></em>身分打開VTune，就解決囉~<br><img src="/../imgs/image5.png" alt="image"></p><h3 id="step-2：開始效能分析"><a href="#step-2：開始效能分析" class="headerlink" title="step 2：開始效能分析"></a>step 2：開始效能分析</h3><p>VTune有好幾種效能分析的方式：</p><ul><li>直連VTune啟動分析：打開VTune GUI，指定要分析的程式，或 在程式已經在跑的情況下，attach到該程式的進程，開始收集資料<br>我一開始最直覺的想嘗試這個做法，網路上大多也是這樣，有興趣的人可以看一下我的研究過程，總之後來試到覺得太沒效率就放棄了嗚嗚</li><li>先用 perf 工具收集，再匯入 VTune：先使用 Linux 的 perf（一個系統級效能分析工具）在命令列收集程式執行的效能事件與統計數據，生成報告檔（如 perf.data），接著打開 VTune，把這些檔案匯入，利用 GUI 做後續分析</li></ul><p>我這邊是用Intel編譯器執行VTune分析，最後再匯入，Windows GUI視覺化</p><p>首先先載入VTune環境變數，如果不知道<code>setvars.sh</code>在哪可以先用指令找(通常在家目錄底下<code>intel/oneapi/setvars.sh</code>)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ~/intel -name setvars.sh 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p>載入環境變數</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source &#123;你的路徑&#125;/intel/oneapi/setvars.sh</span><br></pre></td></tr></table></figure><p>可以用<code>vtune -help</code>測試是否載入成功</p><p>接下來可以開始執行要分析的程式，注意程式在編譯時一定要帶<code>-g</code>才能帶debug info!!!<br>開始分析指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vtune -collect <span class="variable">$COLLECTION_TYPE</span> -r <span class="variable">$RESULT_DIR</span> <span class="variable">$APPLICATION</span></span><br><span class="line"><span class="variable">$APPLICATION_PARAMETERS</span></span><br></pre></td></tr></table></figure><ul><li>$COLLECTION_TYPE：分析類型 (hotspots、memory-access、uarch-exploration 等)</li></ul><p>分析完會打包在剛剛指定的資料夾裡，如果你是連遠端機器可以用scp把資料傳輸回本地端，我是用wsl所以沒有這個問題</p><p>點左側選單的資料夾載入剛剛的<code>.vtune</code>檔就可以開始看分析了~<br><img src="/../imgs/image7.png" alt="image"></p><h2 id="try-erorrrrrrrrrrrr-紀錄"><a href="#try-erorrrrrrrrrrrr-紀錄" class="headerlink" title="try &amp; erorrrrrrrrrrrr 紀錄"></a>try &amp; erorrrrrrrrrrrr 紀錄</h2><p>開始執行後遇到一個大問題：<code>Cannot locate debugging information</code></p><p><img src="/../imgs/image6.png" alt="image"></p><p>其實這樣也能正常執行，只是看不到詳細個別的function，剛開始我以為又是哪個driver沒有安裝好，查下發現以為是因為VTune得接收PDB符號(這個通常用於debug)才能將對應的符號對應到編譯程式中的標示符和指令，還因此走了一大段彎路想盡辦法產生<code>.pdb</code>，後來又看到這篇發問，完全就是我遇到的問題<br><a href="https://community.intel.com/t5/Analyzers/VTune-does-not-show-source-file-even-with-debugging-info-enabled/m-p/1311678#M21281">VTune does not show source file even with debugging info enabled</a></p><p>沒想到在產生<code>.pdb</code>這個步驟我又大大的卡關了<br>首先根據Intel doc有提供產生pdb的流程，但是是在Visual Studio IDE環境下(到現在我才知道原來這跟vs code不一樣)，vs code得手動在編譯時設定選項，而且得改成微軟家自己的MSVC編譯器，因此我就將原本的Makefile改成以下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Compiler settings</span><br><span class="line">CC = cl</span><br><span class="line">CXXFLAGS = /O2 /Zi /EHsc /I$(INCdir)</span><br><span class="line">LDFLAGS = /DEBUG</span><br><span class="line">INCdir = include</span><br></pre></td></tr></table></figure><p>然後就開心的在CMD中make，卻又發現以下問題</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">process_begin: CreateProcess(NULL, cl /O2 /Zi /EHsc /Iinclude /c src/board.cpp /Foobj/board.obj, ...) failed.</span><br><span class="line">make (e=2): make: *** [makefile:36: obj/board.obj] Error 2</span><br></pre></td></tr></table></figure><p>AI說這是因為<code>cl.exe</code> 是 MSVC 編譯器，只存在於 Visual Studio &#x2F; Build Tools 安裝的 Developer Command Prompt 或 Native Tools Command Prompt，普通 shell 找不到路徑，所以 Make 無法執行 cl<br>上網看了很多的資訊都是教如何在visual studio中安裝，或是資訊太久以前，後來發現visual studio code官方是有doc的，跟著做了一次終於可以了(淚目<br><a href="https://code.visualstudio.com/docs/cpp/config-msvc">Configure VS Code for Microsoft C++</a></p><h2 id="開始分析"><a href="#開始分析" class="headerlink" title="開始分析"></a>開始分析</h2><p>這邊請AI幫我整理了一各個功能的用途</p><table><thead><tr><th>名稱</th><th>中文說明</th><th>重點用途</th><th>觀察方向</th></tr></thead><tbody><tr><td><strong>Bottom-up</strong></td><td>自下而上分析</td><td>找出「最耗 CPU 的函式」與它們被誰呼叫，顯示每個函式的「Self Time」和「被誰呼叫」</td><td>🔎 從最底層執行單元往上看「誰造成它被呼叫」</td></tr><tr><td><strong>Caller&#x2F;Callee</strong></td><td>呼叫者&#x2F;被呼叫者關係圖</td><td>看函式之間的呼叫關係與時間分配</td><td>🔄 橫向觀察呼叫關係（誰呼叫誰、誰花最多時間）</td></tr><tr><td><strong>Top-down Tree</strong></td><td>自上而下分析</td><td>看「哪條邏輯路徑」最耗時間，時間是「Inclusive Time（包含所有子呼叫）」</td><td>🌲 從 main() 一路往下展開分析哪裡慢</td></tr><tr><td><strong>Flame Graph</strong></td><td>火焰圖視覺化</td><td>以顏色與長度表示 CPU time（越寬代表越慢），每一層是呼叫堆疊</td><td>🔥 快速直覺找出最熱函式</td></tr><tr><td><strong>Source View</strong></td><td>原始碼檢視</td><td>精確看到哪一行程式碼最耗 CPU</td><td>🧩 找出 bottleneck 行號（結合符號與編譯資訊）</td></tr></tbody></table><p>兩個比較重要的差別</p><ul><li>Bottom-up：想找出「哪個函式最值得優化」</li><li>Top-down Tree：分析「程式流程中哪個階段最慢」</li></ul><p>接著開始分析我的程式，在<code>Summary</code>裡可以看到<em>RLmost</em>是最久CPU time的，所以就先從這裡開始下手<br><img src="https://hackmd.io/_uploads/HJ-jQkZTex.png" alt="image"></p><h3 id="Bottom-up"><a href="#Bottom-up" class="headerlink" title="Bottom-up"></a>Bottom-up</h3><p>進到<code>Bottom-up</code>，可以看到<em>RLmost</em>的call stack，這邊有一個地方我想了很久才搞懂，一開始我以為是顯示total CPU time，也就是執行到該函式時總花費時間，但怎麼看都不合理，因為這樣應該是最高層的caller(main)會最久，但我又想不通如果是self time(函式本身花掉的時間)，為何前面的caller時間加起來剛好是底層<em>RLmost</em>的時間(〒︿〒)<br>還好AI幫我解惑了，其實確實是self time，只是上層caller的時間只是顯示「呼叫這個底層函式時花的時間」，也就是它顯示的是：「這個底層函式的時間，有哪些上層呼叫路徑造成的」</p><p>換句話說：</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>這 161 秒的 CPU time 是 <strong>RLmost 自己執行花掉的時間</strong>，<br>而不是上層函式的時間加起來。</p></blockquote><p><img src="https://hackmd.io/_uploads/Byzp8JZTgg.png" alt="image"></p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>接著看原始碼，<code>Assembly grouping</code>有三種選項，因為一個函式（function）通常會編譯成許多指令與<strong>基本區塊（basic block）</strong>，所以可以選擇「以哪個粒度」來統計與顯示 CPU 使用情況<br><img src="https://hackmd.io/_uploads/BkzQWeWaxx.png" alt="image"></p><ul><li><p>Address：最細的層級。</p><ul><li>每個 CPU 指令的地址都單獨顯示一列。</li><li>可以看到確切哪個指令最耗時（例如 mov eax, [rbx+4]）。</li><li>適合：想追蹤單條機器指令或 pipeline bottleneck 時使用。</li><li>缺點：資料很多，難以閱讀。</li></ul><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>✅ 類似「逐條指令 profiling」。</p></blockquote></li><li><p>Basic Block &#x2F; Address：中間層級（通常最常用）。</p><ul><li>將多條連續的、無跳躍（no branch） 的指令組成一個 Basic Block（基本區塊）。</li><li>你會看到每個基本區塊的總時間與區塊內指令的細部。</li><li>適合：追蹤迴圈、分支內哪一塊程式最慢，但不需要看到所有指令。<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>✅ 類似「以控制流程為單位」的彙編統計。</p></blockquote></li></ul></li><li><p>Function Range &#x2F; Basic Block &#x2F; Address：階層式顯示：函式 → 基本區塊 → 指令。</p><ul><li>最上層：整個函式（例如 RLmost）。</li><li>展開後：各個 basic block。</li><li>再展開：每個指令（address）。</li><li>適合：要從函式級別一路 drill down 到指令級別分析時使用。<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>可快速定位「哪個函式→哪個區塊→哪條指令」最耗 CPU。<br>✅ 類似「函式樹狀 + 基本區塊細節」的整合視圖。<br>📈 通常建議用這個模式來定位 哪一行 C++ 原始碼 對應到哪個彙編區塊最慢。</p></blockquote></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在研究 Nonogram 的過程中，有了幾項有趣的發現：在執行系上高建壹學長撰寫的邏輯規則程式時，我的電腦不僅執行時間縮短了約 30%（應該是硬體效能差異），連 DFS 的呼叫次數也明顯減少。老師因此建議我使用 Profiling 工具VTune，檢測程式在不同階段的效</summary>
      
    
    
    
    <category term="開發紀錄" scheme="https://sandrala0413.git/categories/%E9%96%8B%E7%99%BC%E7%B4%80%E9%8C%84/"/>
    
    
    <category term="VTune" scheme="https://sandrala0413.git/tags/VTune/"/>
    
    <category term="Profiling" scheme="https://sandrala0413.git/tags/Profiling/"/>
    
  </entry>
  
  <entry>
    <title>Docker 新手初探筆記</title>
    <link href="https://sandrala0413.git/post/docker-introduction.html"/>
    <id>https://sandrala0413.git/post/docker-introduction.html</id>
    <published>2025-05-22T12:11:12.000Z</published>
    <updated>2025-09-24T20:28:33.621Z</updated>
    
    <content type="html"><![CDATA[<p>以前在學 Docker 時整理的筆記~之後再慢慢整理一些 Dockerfile、k8s 之類的放上來(๑•̀ㅁ•́๑)✧</p><h2 id="Container-v-s-VM"><a href="#Container-v-s-VM" class="headerlink" title="Container v.s. VM"></a>Container v.s. VM</h2><p>為了增加硬體利用率，會在硬體層上建立一層虛擬化平台，並在平台中建立並運行多個虛擬機(VM)，彼此獨立並共享硬體資源。雖然如此能有效利用硬體資源，但每個VM都須擁有一個獨立的Guest OS，因此會造成幾個問題：</p><ol><li>佔據硬體資源：每個虛擬機都需要使用底層硬體資源建立Guest OS，佔據記憶體與硬碟空間，且還需透過Hypervisor進行虛擬機器與底層資源的溝通</li><li>啟動時間漫長：由於每個VM都含有OS映像檔而導致過於肥大，因此建立和起動都需花費大量時間</li><li>較低的可攜性：會因裝置、作業系統等環境的不同，導致無法執行VM中的應用程式</li></ol><h3 id="容器化-Containerization"><a href="#容器化-Containerization" class="headerlink" title="容器化(Containerization)"></a>容器化(Containerization)</h3><p>是一種連同硬體作業系統與運行服務做虛擬化的技術，讓運作在平台上的容器(Container)<strong>共享一個Host OS的資源</strong>。Container的目標是為了改善VM因Guest OS所導致的問題，所以Container以應用程式為主，包含應用程式與其所需的所有程式庫、環境設定、資料庫與網路設定等，每個Container都擁有完整的運行環境，不會受到其他應用程式或系統的影響，讓應用程式更容易移植和部屬到其他裝置或作業系統<br><img src="https://hackmd.io/_uploads/Hk-Y4Nnq1g.png" alt="image"></p><h2 id="容器映像-Container-Image"><a href="#容器映像-Container-Image" class="headerlink" title="容器映像(Container Image)"></a>容器映像(Container Image)</h2><p>容器映像可理解為一個可執行的軟體包，是一個運行應用程式的環境，包含了可執行程式碼、支援程式庫、運算要求條件及所有依賴項，可以在不同平台運行。每個容器都需載入一個容器映像檔來執行。<br>透過容器化技術，使用者只須將應用程式及相關依賴項打包到一個容器映像中，並指定所需的運行環境，就可以在Docker、Kubernetes等支援容器化技術的平台上運行。<br><img src="https://hackmd.io/_uploads/SJroyB2q1e.png" alt="image"></p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>Docker是一個開源的容器化平台，可以用來打包、運行和分享應用程式。Docker容器實現了應用程式的獨立性和可移植性，讓開發者和運維人員可以更加便捷地進行應用程式的開發、部署和運維。<br>Docker映像檔包含執行軟體所需的一切功能：程式碼、程式執行環境、驅動程式、工具、程式庫、部屬等。<br>Docker 容器是 Docker 映像檔的執行結果。不過，與虛擬機器管理程式的傳統虛擬化不同，Docker 容器會在主機作業系統的核心上執行。在 Docker 映像檔中，沒有如圖 1 所示的個別作業系統。<br><img src="https://hackmd.io/_uploads/Hyx840ncke.png" alt="image"></p><p><strong>優點：</strong></p><ol><li>環境一致性：Docker可以將應用程式及其所有依賴項打包在一個容器中，確保從開發到測試到生產的整個生命週期中環境的一致性。</li><li>輕量級、高性能：與傳統VM相比，Docker容器不須運行一整套OS，而是直接使用主機的OS，使得容器變得非常輕量且執行速度快。</li><li>應用程式隔離：每個容器在其自己的容器中運行，有自己的網路和文件系統等，互不干擾，使得各種應用程式能在同一台機器上共存。</li><li>可移植性：由於容器包含所有需要的依賴項，因此他可以在任何安裝了Docker的系統上運行(不論是在實體機or虛擬機、在數據中心or在雲端)</li><li>易於管理和擴張：Docker提供豐富的工具和平台用於管理容器、服務等，使應用程式的部屬、擴展合為運變得簡單。</li></ol><p><strong>主要功能：</strong></p><ol><li>容器創建和管理：Docker提供創建、啟動、停止、移動和刪除容器的指令</li><li>映像創建和分發：Docker可以創建容器映像，使其可被重複利用或移植到其他環境、分享給其他使用者。可實現應用程式快速部屬和擴展的基礎</li><li>版本控制：Docker支援映像檔的版本控制</li><li>資源隔離：每個 Docker 容器都有自己的檔案系統、自己的網路堆疊 (以及自己的 IP 位址)、自己的處理作業空間，以及針對 CPU 和記憶體定義的資源限制。由於 Docker 容器不需要啟動作業系統，因此會立即啟動。Docker 資源即隔離，例如將主機作業系統的資源隔離，而非虛擬化 (亦即VM提供Host OS系統的Guest OS系統)。</li><li>資源整合：Docker可以將主機的資源如磁盤、網路和文件系統整合到容器中，使容器可以像真實的獨立系統一樣運行。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以前在學 Docker 時整理的筆記~之後再慢慢整理一些 Dockerfile、k8s 之類的放上來(๑•̀ㅁ•́๑)✧&lt;/p&gt;
&lt;h2 id=&quot;Container-v-s-VM&quot;&gt;&lt;a href=&quot;#Container-v-s-VM&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="研究筆記" scheme="https://sandrala0413.git/categories/%E7%A0%94%E7%A9%B6%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="Docker" scheme="https://sandrala0413.git/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>UVa 499 - What&#39;s The Frequency, Kenneth? 解題紀錄</title>
    <link href="https://sandrala0413.git/post/uva-499.html"/>
    <id>https://sandrala0413.git/post/uva-499.html</id>
    <published>2025-05-21T06:36:04.000Z</published>
    <updated>2025-09-24T05:17:51.670Z</updated>
    
    <content type="html"><![CDATA[<p>CPE 考試小小經驗分享，其實多刷一星題練練手感，考試時就至少能答對三題了，一星題大多是考純 IO，少部分才需要用到一點 DP，二星三星也大多使用 DP (可能會一題內跑多個)，還有我在看題目的時候習慣直接看 IO ，真的不懂再回去看樂樂長的題目敘述~</p><h2 id="📘-題目簡述"><a href="#📘-題目簡述" class="headerlink" title="📘 題目簡述"></a>📘 題目簡述</h2><p>判斷句子中哪個字母出現頻率最高</p><hr><h2 id="📤-輸出格式"><a href="#📤-輸出格式" class="headerlink" title="📤 輸出格式"></a>📤 輸出格式</h2><p>若最高頻率字母有多個，則按照字母順序，先大寫再小寫輸出</p><h2 id="📌-題目範例輸入"><a href="#📌-題目範例輸入" class="headerlink" title="📌 題目範例輸入"></a>📌 題目範例輸入</h2><p>When riding your bicycle backwards down a one-way street, if the<br>wheel falls of a canoe, how many ball bearings does it take to fill<br>up a water buffalo?<br>Hello Howard.</p><h2 id="📌-題目範例輸出"><a href="#📌-題目範例輸出" class="headerlink" title="📌 題目範例輸出"></a>📌 題目範例輸出</h2><p>e 6<br>al 7<br>a 3<br>Hlo 2</p><hr><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>直覺做，用一個 int 陣列紀錄每個字母出現的次數</p><h2 id="Java程式碼實作"><a href="#Java程式碼實作" class="headerlink" title="Java程式碼實作"></a>Java程式碼實作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Scanner in = new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        while(in.hasNext())&#123;</span><br><span class="line">            int[] letter = new int[52];     //UpperCase：index 0~25；LowerCase：index 26~51</span><br><span class="line">            int max = 0;</span><br><span class="line"></span><br><span class="line">            String str = in.nextLine();</span><br><span class="line">            for(int i = 0; i &lt; str.length(); i++)&#123;</span><br><span class="line">                char ch = str.charAt(i);</span><br><span class="line">                if(ch &gt;= &#x27;A&#x27; &amp;&amp; ch &lt;= &#x27;Z&#x27;)&#123;</span><br><span class="line">                    letter[ch -&#x27;A&#x27;]++;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(ch &gt;= &#x27;a&#x27; &amp;&amp; ch &lt;= &#x27;z&#x27;)&#123;</span><br><span class="line">                    letter[ch - &#x27;a&#x27; + 26]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for(int i = 0; i &lt; 52; i++)&#123;</span><br><span class="line">                if(letter[i] &gt; max)&#123;</span><br><span class="line">                    max = letter[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            for(int i = 0; i &lt; 52; i++)&#123;</span><br><span class="line">                if(letter[i] == max)&#123;</span><br><span class="line">                    if(i &lt; 26)  System.out.print((char)(i + &#x27;A&#x27;));</span><br><span class="line">                    else        System.out.print((char)(i - 26 + &#x27;a&#x27;));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.print(&quot; &quot; + max + &quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;CPE 考試小小經驗分享，其實多刷一星題練練手感，考試時就至少能答對三題了，一星題大多是考純 IO，少部分才需要用到一點 DP，二星三星也大多使用 DP (可能會一題內跑多個)，還有我在看題目的時候習慣直接看 IO ，真的不懂再回去看樂樂長的題目敘述~&lt;/p&gt;
&lt;h2 id</summary>
      
    
    
    
    <category term="UVa" scheme="https://sandrala0413.git/categories/UVa/"/>
    
    
    <category term="Java" scheme="https://sandrala0413.git/tags/Java/"/>
    
    <category term="UVa-⭐" scheme="https://sandrala0413.git/tags/UVa-%E2%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>UVa 494 - Kindergarten Counting Game 解題紀錄</title>
    <link href="https://sandrala0413.git/post/uva-494.html"/>
    <id>https://sandrala0413.git/post/uva-494.html</id>
    <published>2025-05-21T06:35:46.000Z</published>
    <updated>2025-05-22T12:19:47.015Z</updated>
    
    <content type="html"><![CDATA[<p>夏天到了，把背景圖改成適合夏天的樣子(•̀ᴗ• )<br>昨天 520 終於考完這次的 CPE ，戰績 3 題，達到了我預期中的目標但又有點小遺憾，當天再寫的時候寫完三題時間還綽綽有餘，看後面的題目也不難，結果卡在一個小 bug，但也已經比一年前的我進步很多了啦!<br>前幾天太忙了，這幾天再慢慢努力把之前刷的題補上來~</p><h2 id="📘-題目簡述"><a href="#📘-題目簡述" class="headerlink" title="📘 題目簡述"></a>📘 題目簡述</h2><p>計算一行句子內有幾個 word</p><hr><h2 id="📌-題目範例輸入"><a href="#📌-題目範例輸入" class="headerlink" title="📌 題目範例輸入"></a>📌 題目範例輸入</h2><p>Meep Meep!<br>I tot I taw a putty tat.<br>I did! I did! I did taw a putty tat.<br>Shsssssssssh … I am hunting wabbits. Heh Heh Heh Heh …</p><h2 id="📌-題目範例輸出"><a href="#📌-題目範例輸出" class="headerlink" title="📌 題目範例輸出"></a>📌 題目範例輸出</h2><p>2<br>7<br>10<br>9</p><hr><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>直覺做</p><h2 id="Java程式碼實作"><a href="#Java程式碼實作" class="headerlink" title="Java程式碼實作"></a>Java程式碼實作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Scanner in = new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        while(in.hasNext())&#123;</span><br><span class="line">            String str = in.nextLine();</span><br><span class="line"></span><br><span class="line">            int count = 0;</span><br><span class="line">            boolean isWord = false;</span><br><span class="line">            for(int i = 0; i &lt; str.length();)&#123;</span><br><span class="line">                while(i &lt; str.length() &amp;&amp; Character.isLetter(str.charAt(i++)))&#123;</span><br><span class="line">                    isWord = true;</span><br><span class="line">                &#125;</span><br><span class="line">                if(isWord)  count++;</span><br><span class="line">                isWord = false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;夏天到了，把背景圖改成適合夏天的樣子(•̀ᴗ• )&lt;br&gt;昨天 520 終於考完這次的 CPE ，戰績 3 題，達到了我預期中的目標但又有點小遺憾，當天再寫的時候寫完三題時間還綽綽有餘，看後面的題目也不難，結果卡在一個小 bug，但也已經比一年前的我進步很多了啦!&lt;br&gt;前</summary>
      
    
    
    
    <category term="UVa" scheme="https://sandrala0413.git/categories/UVa/"/>
    
    
    <category term="Java" scheme="https://sandrala0413.git/tags/Java/"/>
    
    <category term="UVa-⭐" scheme="https://sandrala0413.git/tags/UVa-%E2%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>UVa 496 - Simply Subsets 解題紀錄</title>
    <link href="https://sandrala0413.git/post/uva-496.html"/>
    <id>https://sandrala0413.git/post/uva-496.html</id>
    <published>2025-05-21T06:35:10.000Z</published>
    <updated>2025-05-22T12:19:51.173Z</updated>
    
    <content type="html"><![CDATA[<h2 id="📘-題目簡述"><a href="#📘-題目簡述" class="headerlink" title="📘 題目簡述"></a>📘 題目簡述</h2><p>判斷集合之間的關係</p><hr><h2 id="📥-輸入格式"><a href="#📥-輸入格式" class="headerlink" title="📥 輸入格式"></a>📥 輸入格式</h2><p>每兩行輸入代表兩個 set ，第一個為 set A ，第二個為 set B</p><h2 id="📤-輸出格式"><a href="#📤-輸出格式" class="headerlink" title="📤 輸出格式"></a>📤 輸出格式</h2><p>針對每對 set A 、 B 判斷是以下哪四個關係</p><ul><li>A is a proper subset of B</li><li>B is a proper subset of A</li><li>A equals B</li><li>A and B are disjoint</li><li>I’m confused!</li></ul><h2 id="📌-題目範例輸入"><a href="#📌-題目範例輸入" class="headerlink" title="📌 題目範例輸入"></a>📌 題目範例輸入</h2><p>55 27<br>55 27<br>9 24 1995<br>9 24<br>1 2 3<br>1 2 3 4<br>1 2 3<br>4 5 6<br>1 2<br>2 3</p><h2 id="📌-題目範例輸出"><a href="#📌-題目範例輸出" class="headerlink" title="📌 題目範例輸出"></a>📌 題目範例輸出</h2><p>A equals B<br>B is a proper subset of A<br>A is a proper subset of B<br>A and B are disjoint<br>I’m confused!</p><hr><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>原本這題看到第一直覺是純手刻邏輯判斷，後來才發現 Java 有自帶判斷集合的 method</p><h2 id="Java程式碼實作"><a href="#Java程式碼實作" class="headerlink" title="Java程式碼實作"></a>Java程式碼實作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Scanner in = new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        while(in.hasNext())&#123;</span><br><span class="line">            Set&lt;Integer&gt; setA = new HashSet&lt;Integer&gt;();</span><br><span class="line">            Set&lt;Integer&gt; setB = new HashSet&lt;Integer&gt;();</span><br><span class="line">            </span><br><span class="line">            String tmp = in.nextLine();</span><br><span class="line">            for(String s: tmp.split(&quot; &quot;))&#123;</span><br><span class="line">                setA.add(Integer.valueOf(s));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tmp = in.nextLine();</span><br><span class="line">            for(String s: tmp.split(&quot; &quot;))&#123;</span><br><span class="line">                setB.add(Integer.valueOf(s));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(setA.equals(setB))           System.out.println(&quot;A equals B&quot;);</span><br><span class="line">            else if(setA.containsAll(setB))    System.out.println(&quot;B is a proper subset of A&quot;);</span><br><span class="line">            else if(setB.containsAll(setA))    System.out.println(&quot;A is a proper subset of B&quot;);</span><br><span class="line">            else if(Collections.disjoint(setA, setB))   System.out.println(&quot;A and B are disjoint&quot;);</span><br><span class="line">            else                            System.out.println(&quot;I&#x27;m confused!&quot;);                     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;📘-題目簡述&quot;&gt;&lt;a href=&quot;#📘-題目簡述&quot; class=&quot;headerlink&quot; title=&quot;📘 題目簡述&quot;&gt;&lt;/a&gt;📘 題目簡述&lt;/h2&gt;&lt;p&gt;判斷集合之間的關係&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;📥-輸入格式&quot;&gt;&lt;a href=&quot;#📥-輸</summary>
      
    
    
    
    <category term="UVa" scheme="https://sandrala0413.git/categories/UVa/"/>
    
    
    <category term="Java" scheme="https://sandrala0413.git/tags/Java/"/>
    
    <category term="UVa-⭐" scheme="https://sandrala0413.git/tags/UVa-%E2%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>實作筆記｜c++ 實作 Nonogram 演算法</title>
    <link href="https://sandrala0413.git/post/nonogram.html"/>
    <id>https://sandrala0413.git/post/nonogram.html</id>
    <published>2025-05-11T15:54:11.000Z</published>
    <updated>2025-10-03T20:08:04.859Z</updated>
    
    <content type="html"><![CDATA[<p>之前高效能運算課堂時老師提到了一個蠻有趣的論文，是由陽明交大資工系吳毅成教授團隊發表的 —— <strong>An Efficient Approach to Solving Nonograms (Wu et al., 2013)</strong><br>內容主要是提出一個更快的演算法來處理 Nonogram（一種黑白格填點遊戲）裡的 line solving(一行一行解題)，再搭配幾個 Fully Probing (FP) 的小技巧，把能確定的格子盡量先塗掉，最後才交給 backtracking</p><p>系上一直都有學長姊在研究這個領域，也贏了很多次TCGA、ICGA電腦對局研討會的Nonogram冠軍，因為看著蠻好玩的就好奇動手把論文的方法實作了一下，用的是TCGA的標準。本來以為是小插曲，沒想到後來意外成為我國科會大專生研究計畫的主題哈哈，這篇除了是實作筆記也當作我再一次整理整個演算法的思路</p><p>我的程式是根據後面有提到的TCGA規則寫的，有興趣的也可以到 <a href="https://github.com/Sandrala0413/Nonogram-SimpleVersion">github</a> 看看我的程式碼~~~</p><hr><h2 id="論文的核心想法"><a href="#論文的核心想法" class="headerlink" title="論文的核心想法"></a>論文的核心想法</h2><p>論文中的解題方法是屬於單格導向的解題模式(現在也有如我正在研究的區塊挪移、邏輯規則求解等其他方法)。裡面演算法主要分為三個部分：</p><ol><li>Propagate: 基於動態規劃，反覆對單行或列進行猜測求解，直至不再有進展</li><li>Fully Probing(FP): 針對尚未求得解的格子，分別猜測填黑或填白，然後再執行Propagate，檢驗何者會與目前盤面及線索相衝突(則另一不會導致衝突者，就是正確的解答方向)，若兩者都不會導致衝突，則填黑和填白的擴展後盤面取交集，即是可新求得解的格子</li><li>Backtracking: 最後再以回溯搜尋法來求得所有剩餘格子的解答(其中會再反覆用到前一部分的Fully Probing方法)</li></ol><h3 id="1-Line-Solving-Propagation-with-DP"><a href="#1-Line-Solving-Propagation-with-DP" class="headerlink" title="1. Line Solving &amp; Propagation with DP"></a>1. Line Solving &amp; Propagation with DP</h3><p>傳統做法大多靠規則（rule-based）或 SAT&#x2F;ILP 轉換，速度或正確性都有限。<br>這篇論文的重點是 <strong>DP line solving</strong>：針對一條 row&#x2F;col，快速判斷哪些格子一定是黑、一定是白。 </p><p>論文中 DP 有幾個主要函數：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Fix(i, j) -&gt; 迴圈，驗證Si是否有解(fixble)</span><br><span class="line">Fix0(i, j) -&gt; 設si = 0(空白格)</span><br><span class="line">Fix1(i, j) -&gt; 設si = 1(黑格)</span><br></pre></td></tr></table></figure><p>完整pseudo code<br><img src="/../imgs/image8.jpg" alt="image"><br>其中</p><ul><li>s[i] &#x3D; line 的第 i 個 cell 狀態（0 &#x3D; 白, 1 &#x3D; 黑, u &#x3D; 未知）</li><li>d[j] &#x3D; 第 j 個 clue 的黑塊長度</li><li>σ(d[j]) &#x3D; 長度為 d[j] 的黑塊 pattern（連續 d[j] 個黑格）</li><li>segment(s[i]-d[j] .. s[i]) &#x3D; 從 i-d[j] 到 i 的 substring</li></ul><p>Fix(l, k) 時間複雜度是 <strong>O(kl)</strong></p><h4 id="The-line-solving-problem：找到S的maximal-painting-S’"><a href="#The-line-solving-problem：找到S的maximal-painting-S’" class="headerlink" title="The line-solving problem：找到S的maximal painting S’"></a>The line-solving problem：找到S的maximal painting S’</h4><p>這裡的S &#x3D; s<del>1</del>s<del>2</del> … s<del>l</del>，代表該line和線索相符的string，S’則是S朝解更進一步的記號，所以這個部分的目標就是找到S最大的解(也就是全部都被標記上0、1、u，且符合線索)</p><p>論文裡用到的函數稱為Paint，跟前面的Fix差別在於，Fix是試試看這樣填會不會有錯，Paint是真正將解填進去格子(填了就不能返回)<br>Fix會以一整條line來看，呼叫Fix來判斷是否有解<br><img src="/../imgs/image9.jpg" alt="image"><br>主要用到的填點技術是<code>Merge</code>，當Fix0、Fix1都成立時，代表那個點填0 or 1都行，就可以取當下兩個盤面的交集點，也就是可以確定的解，其他則依然unknown</p><p>Paint(l, k)時間複雜度為<strong>O(kl^2)</strong></p><h4 id="Propagation：把row、col的線索拿出來更進一步解"><a href="#Propagation：把row、col的線索拿出來更進一步解" class="headerlink" title="Propagation：把row、col的線索拿出來更進一步解"></a>Propagation：把row、col的線索拿出來更進一步解</h4><p><img src="/../imgs/image10.png" alt="image"></p><h3 id="2-Fully-Probing-FP"><a href="#2-Fully-Probing-FP" class="headerlink" title="2. Fully Probing (FP)"></a>2. Fully Probing (FP)</h3><p>光靠 DP，還是會留下很多「未知」格子。<br>FP 的概念就是：在propagate完後先隨便挑一格u，假裝猜其是黑&#x2F;白 → propagate檢查是否conflict → 看能不能推出新資訊。<br>論文裡面提出了三種FP演算法</p><ul><li><p>FP1：最簡單，逐格嘗試</p></li><li><p>FP2：加上「反推（contrapositive）」，推出更多隱含關係</p></li><li><p>FP3：進一步做類似 2-SAT 的關聯推理</p></li></ul><p>一個簡單的 FP1 片段，有興趣的人可以去翻翻原論文：<br><img src="/../imgs/image11.png" alt="image"></p><p><img src="/../imgs/image12.png" alt="image"><br>其中</p><ul><li>G<del>p,0</del>：猜p &#x3D; 0後的牌面</li><li>G<del>p,1</del>：猜p &#x3D; 1後的牌面</li></ul><p>這邊的 PROBE 裡的<code>CONFLICT</code>不是代表無解，而是因為前面Backtracking時可能就猜錯了所以導致無解(因為Backtracking是同時猜測多個點)<br>而 FP1 中迴圈裡是否要有那個<code>break</code>也是一個可以探討的問題，因為多了這個break出去更新牌面是有可能增加更多解，但也可能會增加計算量導致效率變低</p><h3 id="3-Backtracking-選點策略"><a href="#3-Backtracking-選點策略" class="headerlink" title="3. Backtracking + 選點策略"></a>3. Backtracking + 選點策略</h3><p>當 FP 再也解不出點，就得進入Backtracking回溯<br>這裡選<strong>哪一格來猜</strong>很重要，好的 heuristic 能大幅減少遞迴深度，所以選點策略也是Nonogram研究中值得拿出來探討的事，論文裡也提出了6種選點策略，有趣的是交大自己實測最快的選點策略跟我們系上學長姐實驗出來的完全不一樣，所以這個議題還是蠻好玩的<br><img src="/../imgs/image13.png" alt="alt text"></p><h3 id="Nonogram競賽規則-TCGA"><a href="#Nonogram競賽規則-TCGA" class="headerlink" title="Nonogram競賽規則(TCGA)"></a>Nonogram競賽規則(TCGA)</h3><p>TCGA是台灣電腦對局研討會，每年大約5月時除了會發表電腦對局相關的研究成果，也會舉辦電腦對局競賽，其中就有一項是Nonogram，規則如下</p><ul><li>每題題目編號前有 <strong>$</strong> ，後面會跟著線索</li><li>每個題目為25*25之大小Nonogram盤面，線索共有50行，前25行代表row的線索(上到下)，後25行代表col的線索(左到右)</li><li>solution需存於25*25大小矩陣， <strong>0</strong> 代表空白格， <strong>1</strong> 代表黑格</li><li>每個線索跟解之間需用TAB相隔</li><li>所有程式都會跑在同一台電腦，且只能使用單顆CPU</li><li>程式只能按照題目順序解題，不能跳題</li><li>一個題目可能有多個解，只需解出其中一個就可以</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前高效能運算課堂時老師提到了一個蠻有趣的論文，是由陽明交大資工系吳毅成教授團隊發表的 —— &lt;strong&gt;An Efficient Approach to Solving Nonograms (Wu et al., 2013)&lt;/strong&gt;&lt;br&gt;內容主要是提出一個</summary>
      
    
    
    
    <category term="實作紀錄" scheme="https://sandrala0413.git/categories/%E5%AF%A6%E4%BD%9C%E7%B4%80%E9%8C%84/"/>
    
    
    <category term="Nonogram" scheme="https://sandrala0413.git/tags/Nonogram/"/>
    
  </entry>
  
  <entry>
    <title>UVa 255 - Correct Move 解題紀錄</title>
    <link href="https://sandrala0413.git/post/uva-255.html"/>
    <id>https://sandrala0413.git/post/uva-255.html</id>
    <published>2025-05-08T11:09:19.000Z</published>
    <updated>2025-09-24T20:43:05.510Z</updated>
    
    <content type="html"><![CDATA[<p>這題其實不難，就是讀題目讀的我很煩…英文能力仍需加強阿三三</p><h2 id="📝-題目簡介"><a href="#📝-題目簡介" class="headerlink" title="📝 題目簡介"></a>📝 題目簡介</h2><p>有一個 8x8 的棋盤，總共有 64 格位置，編號從 0 到 63。棋盤上有兩個棋子：國王 (King) 和 皇后 (Queen)。每次我們會給定一個棋盤狀態，其中包含國王和皇后的位置，以及皇后計算出的新位置</p><p><img src="/../imgs/image.png" alt="棋盤"></p><ul><li><p>legal state：如果國王和皇后不在同一位置。</p></li><li><p>legal move：國王和皇后根據規則移動。</p></li><li><p>allowed move：當國王和皇后移動後，它們不會移動到對方能夠移動到的位置。</p></li></ul><h4 id="棋盤移動規則"><a href="#棋盤移動規則" class="headerlink" title="棋盤移動規則"></a>棋盤移動規則</h4><ul><li><p>king：國王可以每次移動一格，方向是水平或垂直，不能到達皇后所在的位置</p></li><li><p>queen：皇后可以移動一格或多格，方向是水平或垂直，不能到達國王所在的位置</p></li><li><p>禁止king、queen移動到同一位置</p></li></ul><hr><h2 id="📌-題目輸入格式"><a href="#📌-題目輸入格式" class="headerlink" title="📌 題目輸入格式"></a>📌 題目輸入格式</h2><ul><li><p>每行包含三個整數，分別是國王、皇后和皇后計算出來的新位置（範圍為 0 至 63）</p></li><li><p>需要判斷輸入是否符合上述條件</p></li></ul><h2 id="📌-題目輸出格式"><a href="#📌-題目輸出格式" class="headerlink" title="📌 題目輸出格式"></a>📌 題目輸出格式</h2><ul><li><p>Illegal state：如果國王和皇后在同一格上</p></li><li><p>Illegal move：如果狀態是合法的，但皇后的移動不符合規則</p></li><li><p>Move not allowed：如果狀態合法且皇后移動符合規則，但移動會使國王和皇后移動到對方的合法位置。</p></li><li><p>Continue：如果國王和皇后移動後的狀態合法，並且國王仍然有合法的移動。</p></li><li><p>Stop：如果國王在移動後無法合法移動，處於被鎖死狀態。</p></li></ul><hr><h2 id="📌-題目範例輸入"><a href="#📌-題目範例輸入" class="headerlink" title="📌 題目範例輸入"></a>📌 題目範例輸入</h2><p>17 17 49<br>17 49 56<br>17 49 9<br>17 49 17<br>17 49 25<br>17 49 33<br>17 49 41<br>17 49 49<br>56 48 49</p><h2 id="📌-題目範例輸出"><a href="#📌-題目範例輸出" class="headerlink" title="📌 題目範例輸出"></a>📌 題目範例輸出</h2><p>Illegal state<br>Illegal move<br>Illegal move<br>Illegal move<br>Move not allowed<br>Continue<br>Continue<br>Illegal move<br>Stop</p><hr><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><ul><li>位置 % 8 可以得到 x 座標(左至右)</li><li>位置 &#x2F; 8 可以得到 y 座標(上至下)</li><li>stop 可以直接鎖死四個角來判斷，因為只有 king 在四個角時才有可能不能移動</li></ul><h2 id="💻-Java-程式碼實作"><a href="#💻-Java-程式碼實作" class="headerlink" title="💻 Java 程式碼實作"></a>💻 Java 程式碼實作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Main&#123;</span><br><span class="line"></span><br><span class="line">    public static boolean isBetween(int queen, int king, int queen2)&#123;</span><br><span class="line">        if(queen2 &gt; queen)&#123;</span><br><span class="line">            int tmp = queen2;</span><br><span class="line">            queen2 = queen;</span><br><span class="line">            queen = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        if(queen &gt; king &amp;&amp; king &gt; queen2)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Scanner in = new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        while(in.hasNext())&#123;</span><br><span class="line">            int king = in.nextInt();</span><br><span class="line">            int queen = in.nextInt();</span><br><span class="line">            int queen2 = in.nextInt();</span><br><span class="line"></span><br><span class="line">            if(king == queen)&#123;</span><br><span class="line">                System.out.println(&quot;Illegal state&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int kingX = king % 8;</span><br><span class="line">            int kingY = king / 8;</span><br><span class="line">            int queenX = queen % 8;</span><br><span class="line">            int queenY = queen / 8;</span><br><span class="line">            int queen2X = queen2 % 8;</span><br><span class="line">            int queen2Y = queen2 / 8;</span><br><span class="line"></span><br><span class="line">            boolean illegalMove = false;</span><br><span class="line">            if(queenX != queen2X &amp;&amp; queenY != queen2Y)&#123;     //queen moves diagonally</span><br><span class="line">                illegalMove = true;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(queen == queen2 || queen2 == king)&#123;      </span><br><span class="line">                illegalMove = true;</span><br><span class="line">            &#125;</span><br><span class="line">            //queen2 across king</span><br><span class="line">            else if((queenX == kingX &amp;&amp; queenX == queen2X &amp;&amp; isBetween(queenY, kingY, queen2Y)) || (queenY == kingY &amp;&amp; queenY == queen2Y &amp;&amp; isBetween(queenX, kingX, queen2X)))&#123;</span><br><span class="line">                illegalMove = true;</span><br><span class="line">            &#125;</span><br><span class="line">            if(illegalMove)&#123;</span><br><span class="line">                System.out.println(&quot;Illegal move&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if((king + 1 == queen2 &amp;&amp; queen2X != 0) || (king - 1 == queen2 &amp;&amp; queen2X != 7) || (king + 8 == queen2) || (king - 8 == queen2))&#123;</span><br><span class="line">                System.out.println(&quot;Move not allowed&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if((queen2 == 9 &amp;&amp; king == 0) || (queen2 == 14 &amp;&amp; king == 7) || (queen2 == 49 &amp;&amp; king == 56) || (queen2 == 54 &amp;&amp; king == 63))&#123;</span><br><span class="line">                System.out.println(&quot;Stop&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                System.out.println(&quot;Continue&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>碎碎念時間，好幾天沒練習了，上周六參加 PMI 專案管理競賽的台灣區決審，雖然技術層面上跟資工沒有太大的相關，但想著可以累積 PM 專案管理相關的經驗也不錯，還是投入很多心力在準備，為了這個比賽已經忙一個多月</p><p>剛開始準備的時候真的完全摸不著頭緒，第一專案管理、商業分析啥的對一個純理工女真的太抽象嗚嗚，再來比賽規則可能是因為台灣區才第二年辦這個比賽，所以規則也不太明確，一下子說只需初審只需繳交十頁左右的計畫書，後來又說改成最多 60 頁的完整專案計畫書，我們也秉持著寫好寫滿的原則，狠狠的肝了許多 PMBOK 啥的專案管理的專業書籍，最後也寫出了 60 頁交出去初審，也順利進了決審，隔一週決審</p><p>沒想到比寫專案計畫書還頭痛的事情來了，首先我們做的簡報真的醜的達咩爹斯，非常理工直男風，那個禮拜幾乎都在搞美編，真的把我美術細胞都榨乾了，後來又發現決審的簡報時間只有 15 分鐘，但我們整整有110 幾頁 ppt ，接著一天內的時間又緊急刪減了十幾頁，後來大家是用飆車的速度才順利講完</p><p>比賽當天被告知 QA 是以同問同答的方式，我第一次體驗，還好當天比賽蠻順利的，隊友也給力，誰能想到比賽前一次練習我們都還沒壓縮好簡報時間呢，果然是需要一點腎上腺素爆發，結果也很幸運有進前三名，下個月就要代表台灣區比國際賽啦，祝我們繼續順利吧!!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;這題其實不難，就是讀題目讀的我很煩…英文能力仍需加強阿三三&lt;/p&gt;
&lt;h2 id=&quot;📝-題目簡介&quot;&gt;&lt;a href=&quot;#📝-題目簡介&quot; class=&quot;headerlink&quot; title=&quot;📝 題目簡介&quot;&gt;&lt;/a&gt;📝 題目簡介&lt;/h2&gt;&lt;p&gt;有一個 8x8 的棋盤，總</summary>
      
    
    
    
    <category term="UVa" scheme="https://sandrala0413.git/categories/UVa/"/>
    
    
    <category term="Java" scheme="https://sandrala0413.git/tags/Java/"/>
    
    <category term="UVa-⭐⭐" scheme="https://sandrala0413.git/tags/UVa-%E2%AD%90%E2%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>UVa 490 - Rotating Sentences 解題紀錄</title>
    <link href="https://sandrala0413.git/post/uva-490.html"/>
    <id>https://sandrala0413.git/post/uva-490.html</id>
    <published>2025-05-06T19:25:13.000Z</published>
    <updated>2025-05-22T12:19:42.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="📘-題目簡述"><a href="#📘-題目簡述" class="headerlink" title="📘 題目簡述"></a>📘 題目簡述</h2><p>把輸入檔案由最後一行開始，由上至下轉置輸出</p><hr><h2 id="📥-輸入格式"><a href="#📥-輸入格式" class="headerlink" title="📥 輸入格式"></a>📥 輸入格式</h2><p>給定最多 100 行 sentence ，每行不超過 100 個字元</p><h2 id="📤-輸出格式"><a href="#📤-輸出格式" class="headerlink" title="📤 輸出格式"></a>📤 輸出格式</h2><p>從最後一行由左至右垂直輸出</p><h2 id="📌-題目範例輸入"><a href="#📌-題目範例輸入" class="headerlink" title="📌 題目範例輸入"></a>📌 題目範例輸入</h2><p>Rene Decartes once said,<br>“I think, therefore I am.”</p><h2 id="📌-題目範例輸出"><a href="#📌-題目範例輸出" class="headerlink" title="📌 題目範例輸出"></a>📌 題目範例輸出</h2><p>“R<br>Ie<br>n<br>te<br>h<br>iD<br>ne<br>kc<br>,a<br>r<br>tt<br>he<br>es<br>r<br>eo<br>fn<br>oc<br>re<br>e<br>s<br>Ia<br>i<br>ad<br>m,<br>.<br>“</p><hr><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>直覺做，只要把每行輸入都用空白補成相同長度，輸出就很簡單了</p><h2 id="Java程式碼實作"><a href="#Java程式碼實作" class="headerlink" title="Java程式碼實作"></a>Java程式碼實作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Scanner in = new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; line = new ArrayList&lt;&gt;();</span><br><span class="line">        String tmp;</span><br><span class="line">        int max = 0;</span><br><span class="line">        while(in.hasNext())&#123;</span><br><span class="line">            tmp = in.nextLine();</span><br><span class="line">            line.add(tmp);</span><br><span class="line">            if(tmp.length() &gt; max)  max = tmp.length();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; line.size(); i++)&#123;</span><br><span class="line">            tmp = line.get(i);</span><br><span class="line">            while(tmp.length() &lt; max)&#123;</span><br><span class="line">                tmp += &quot; &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            line.set(i, tmp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; max; i++)&#123;</span><br><span class="line">            for(int j = line.size() - 1; j &gt;= 0; j--)&#123;</span><br><span class="line">                System.out.print(line.get(j).charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;📘-題目簡述&quot;&gt;&lt;a href=&quot;#📘-題目簡述&quot; class=&quot;headerlink&quot; title=&quot;📘 題目簡述&quot;&gt;&lt;/a&gt;📘 題目簡述&lt;/h2&gt;&lt;p&gt;把輸入檔案由最後一行開始，由上至下轉置輸出&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;📥-輸入格式&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="UVa" scheme="https://sandrala0413.git/categories/UVa/"/>
    
    
    <category term="Java" scheme="https://sandrala0413.git/tags/Java/"/>
    
    <category term="UVa-⭐" scheme="https://sandrala0413.git/tags/UVa-%E2%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>UVa 245 Uncompress 解題紀錄</title>
    <link href="https://sandrala0413.git/post/uva-245.html"/>
    <id>https://sandrala0413.git/post/uva-245.html</id>
    <published>2025-05-06T19:25:04.000Z</published>
    <updated>2025-05-22T12:19:07.099Z</updated>
    
    <content type="html"><![CDATA[<h2 id="📝-題目簡介"><a href="#📝-題目簡介" class="headerlink" title="📝 題目簡介"></a>📝 題目簡介</h2><p>把壓縮過的檔案還原，壓縮檔案包含 word 和數字，未壓縮檔沒有數字。壓縮檔中，若遇到先前沒有出現過的 word ，則將該 word 放到 list 的最前面(index 從 1 開始)；若遇到之前出現過的 word ，則用 list 中該 word 的 index 代替，並將該 word 移到 list 最前面；遇到非英文 or 數字的字元直接輸出</p><hr><h2 id="📌-題目輸入格式"><a href="#📌-題目輸入格式" class="headerlink" title="📌 題目輸入格式"></a>📌 題目輸入格式</h2><ul><li>沒有 word 超過 50 字元</li><li>大小寫是有區分的<ul><li>eg. <strong>abc</strong> 不等於 <strong>Abc</strong></li></ul></li><li>輸入 0 時結束</li></ul><h2 id="📌-題目輸出格式"><a href="#📌-題目輸出格式" class="headerlink" title="📌 題目輸出格式"></a>📌 題目輸出格式</h2><p>輸出解壓縮後的檔案</p><h2 id="📌-題目範例輸入"><a href="#📌-題目範例輸入" class="headerlink" title="📌 題目範例輸入"></a>📌 題目範例輸入</h2><p>Dear Sally,<br>Please, please do it–1 would 4<br>Mary very, 1 much. And 4 6<br>8 everything in 5’s power to make<br>14 pay off for you.<br>– Thank 2 18 18–<br>0</p><h2 id="📌-題目範例輸出"><a href="#📌-題目範例輸出" class="headerlink" title="📌 題目範例輸出"></a>📌 題目範例輸出</h2><p>Dear Sally,<br>Please, please do it–it would please<br>Mary very, very much. And Mary would<br>do everything in Mary’s power to make<br>it pay off for you.<br>– Thank you very much–</p><hr><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>用 ArrayList&lt;&gt; 存取 list ，因為可以直接指定要拿取、刪除、新增的 index ，我覺得拿來實作這題很方便。<br>當遇到字元是字母時就繼續讀取下去，存到字串中，直到讀取到不是字母的字元，再把該 word 存到 list 中；數字同理，存取到完整數字後轉為 index 到 list 中取出 word ，再把該 word 移到 list 最前面</p><h2 id="💻-Java-程式碼實作"><a href="#💻-Java-程式碼實作" class="headerlink" title="💻 Java 程式碼實作"></a>💻 Java 程式碼實作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Scanner in = new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; token = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        while(true)&#123;</span><br><span class="line">            String str = in.nextLine();</span><br><span class="line">            if(str.equals(&quot;0&quot;)) break;</span><br><span class="line"></span><br><span class="line">            String tmp = &quot;&quot;;</span><br><span class="line">            for(int i = 0; i &lt; str.length();)&#123;</span><br><span class="line">                char ch = str.charAt(i);</span><br><span class="line">                if(Character.isLetter(ch))&#123;</span><br><span class="line">                    while(i &lt; str.length() &amp;&amp; Character.isLetter(str.charAt(i)))&#123;</span><br><span class="line">                        tmp += str.charAt(i++);</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.print(tmp);</span><br><span class="line">                    token.add(0, tmp);</span><br><span class="line">                    tmp = &quot;&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(Character.isDigit(ch))&#123;</span><br><span class="line">                    int index = 0;</span><br><span class="line">                    while(i &lt; str.length() &amp;&amp; Character.isDigit(str.charAt(i)))&#123;</span><br><span class="line">                        index = index * 10 + str.charAt(i++) - &#x27;0&#x27;; </span><br><span class="line">                    &#125;</span><br><span class="line">                    String s = token.get(index-1);</span><br><span class="line">                    System.out.print(s);</span><br><span class="line">                    token.remove(index - 1);</span><br><span class="line">                    token.add(0, s);</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    System.out.print(ch);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;📝-題目簡介&quot;&gt;&lt;a href=&quot;#📝-題目簡介&quot; class=&quot;headerlink&quot; title=&quot;📝 題目簡介&quot;&gt;&lt;/a&gt;📝 題目簡介&lt;/h2&gt;&lt;p&gt;把壓縮過的檔案還原，壓縮檔案包含 word 和數字，未壓縮檔沒有數字。壓縮檔中，若遇到先前沒有出現過</summary>
      
    
    
    
    <category term="UVa" scheme="https://sandrala0413.git/categories/UVa/"/>
    
    
    <category term="Java" scheme="https://sandrala0413.git/tags/Java/"/>
    
    <category term="UVa-⭐⭐" scheme="https://sandrala0413.git/tags/UVa-%E2%AD%90%E2%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>UVa 151 - Power Crisis 解題紀錄</title>
    <link href="https://sandrala0413.git/post/uva-151.html"/>
    <id>https://sandrala0413.git/post/uva-151.html</id>
    <published>2025-05-05T14:24:40.000Z</published>
    <updated>2025-05-22T12:19:01.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="📝-題目簡介"><a href="#📝-題目簡介" class="headerlink" title="📝 題目簡介"></a>📝 題目簡介</h2><p>有編號 1~N 個能源廠，每次從第 1 個開始關閉，第 13 個最後關閉</p><p>寫這個題目學到約瑟夫環(Josephus Problem)這個數學問題，這題是他的變形。傳統約瑟夫問題是由第 1 個人開始報數，報數到 3 的人就要自殺，再從下一個人重新報數，直到剩下一個倖存者。而這題是指定最後一個要存活的 index </p><hr><h2 id="📌-題目輸入格式"><a href="#📌-題目輸入格式" class="headerlink" title="📌 題目輸入格式"></a>📌 題目輸入格式</h2><p>每行輸入代表此次 N 值，輸入為 0 時結束</p><h2 id="📌-題目輸出格式"><a href="#📌-題目輸出格式" class="headerlink" title="📌 題目輸出格式"></a>📌 題目輸出格式</h2><p>輸出能使編號 13 能源廠最後關閉的最小 m 值</p><h2 id="📌-題目範例輸入"><a href="#📌-題目範例輸入" class="headerlink" title="📌 題目範例輸入"></a>📌 題目範例輸入</h2><p>17<br>0</p><h2 id="📌-題目範例輸出"><a href="#📌-題目範例輸出" class="headerlink" title="📌 題目範例輸出"></a>📌 題目範例輸出</h2><p>7</p><hr><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>如果用直覺的作法，有 N 個能源廠，嘗試 m &#x3D; 1, 2, 3 …，每次模擬都要跑 N 輪，時間複雜度是 O(Nm)，但若用約瑟夫遞迴公式，可降到 O(N)</p><ul><li>公式：f(N, M) &#x3D; (f(N-1, M) + M) % N</li><li>f(N, M)：N 個人，報數到 M 的人自殺時，最終活下來的人的編號<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>注意：編號從 0 開始</p></blockquote></li></ul><p>因為編號 1 能源廠一定第一個關閉，所以可視為只有 N-1 個能源廠在做約瑟夫問題，又因為公式 index 是從 0 開始，所以最後判斷的編號為 11</p><h2 id="💻-Java-程式碼實作"><a href="#💻-Java-程式碼實作" class="headerlink" title="💻 Java 程式碼實作"></a>💻 Java 程式碼實作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Scanner in = new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        int n = in.nextInt();</span><br><span class="line">        while(n != 0)&#123;</span><br><span class="line">            n--;        //always turn off number 1 first</span><br><span class="line">            int m = 1;</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                int s = 0;</span><br><span class="line">                for(int j = 2; j &lt;= n; j++)&#123;</span><br><span class="line">                    s = (s + m) % j;</span><br><span class="line">                &#125;</span><br><span class="line">                if(s == 11) break;  //index 0~11</span><br><span class="line">                m++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(m);</span><br><span class="line"></span><br><span class="line">            n = in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;📝-題目簡介&quot;&gt;&lt;a href=&quot;#📝-題目簡介&quot; class=&quot;headerlink&quot; title=&quot;📝 題目簡介&quot;&gt;&lt;/a&gt;📝 題目簡介&lt;/h2&gt;&lt;p&gt;有編號 1~N 個能源廠，每次從第 1 個開始關閉，第 13 個最後關閉&lt;/p&gt;
&lt;p&gt;寫這個題目學</summary>
      
    
    
    
    <category term="UVa" scheme="https://sandrala0413.git/categories/UVa/"/>
    
    
    <category term="Java" scheme="https://sandrala0413.git/tags/Java/"/>
    
    <category term="UVa-⭐⭐" scheme="https://sandrala0413.git/tags/UVa-%E2%AD%90%E2%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>UVa 482 - Permutation Arrays</title>
    <link href="https://sandrala0413.git/post/UVA-482.html"/>
    <id>https://sandrala0413.git/post/UVA-482.html</id>
    <published>2025-05-03T02:56:33.000Z</published>
    <updated>2025-05-22T12:19:38.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="📘-題目簡述"><a href="#📘-題目簡述" class="headerlink" title="📘 題目簡述"></a>📘 題目簡述</h2><p>給定一組浮點數陣列 x 和一個「索引排列陣列」 p ，要求依據排列陣列 p 將 x 中的資料重新排列</p><hr><h2 id="📥-輸入格式"><a href="#📥-輸入格式" class="headerlink" title="📥 輸入格式"></a>📥 輸入格式</h2><ul><li>第一行為一個整數，代表測資數，後面跟著一行空白</li><li>每個測資包含兩行，測資間用空白行相隔<ul><li>第一行：index 陣列 p</li><li>第二行：浮點數陣列</li></ul></li></ul><h2 id="📤-輸出格式"><a href="#📤-輸出格式" class="headerlink" title="📤 輸出格式"></a>📤 輸出格式</h2><ul><li>將浮點數以 p 的順序重新排列後輸出，每個數字一行</li><li>不能改變輸入格式</li><li>不同測資間用空白行相隔</li></ul><h2 id="📌-題目範例輸入"><a href="#📌-題目範例輸入" class="headerlink" title="📌 題目範例輸入"></a>📌 題目範例輸入</h2><p>1</p><p>3 1 2<br>32.0 54.7 -2</p><h2 id="📌-題目範例輸出"><a href="#📌-題目範例輸出" class="headerlink" title="📌 題目範例輸出"></a>📌 題目範例輸出</h2><p>54.7<br>-2<br>32.0</p><hr><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>直覺做，主要困難點於讀取輸入的部分，先用字串讀取一整行，再用 split() 分隔每個 token，這樣也能保留浮點數的格式</p><h2 id="Java程式碼實作"><a href="#Java程式碼實作" class="headerlink" title="Java程式碼實作"></a>Java程式碼實作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Scanner in = new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        int n = in.nextInt();</span><br><span class="line">        in.nextLine();</span><br><span class="line">        in.nextLine();</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; n; i ++)&#123;</span><br><span class="line">            String tmp = in.nextLine();             //read permutation array</span><br><span class="line">            String[] token1 = tmp.split(&quot; &quot;);</span><br><span class="line">            int[] p = new int[token1.length];</span><br><span class="line">            int length = p.length;</span><br><span class="line">            for(int j = 0; j &lt; length; j++)&#123;</span><br><span class="line">                p[j] = Integer.parseInt(token1[j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tmp = in.nextLine();</span><br><span class="line">            String[] floatString = tmp.split(&quot; &quot;);</span><br><span class="line"></span><br><span class="line">            String[] ans = new String[length];</span><br><span class="line">            for(int j = 0; j &lt; length; j++)&#123;</span><br><span class="line">                ans[p[j] - 1] = floatString[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for(int j = 0; j &lt; length; j++)&#123;</span><br><span class="line">                System.out.println(ans[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(i &lt; n - 1)&#123;</span><br><span class="line">                System.out.println(&quot;&quot;);</span><br><span class="line">                in.nextLine();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;📘-題目簡述&quot;&gt;&lt;a href=&quot;#📘-題目簡述&quot; class=&quot;headerlink&quot; title=&quot;📘 題目簡述&quot;&gt;&lt;/a&gt;📘 題目簡述&lt;/h2&gt;&lt;p&gt;給定一組浮點數陣列 x 和一個「索引排列陣列」 p ，要求依據排列陣列 p 將 x 中的資料重新排列</summary>
      
    
    
    
    <category term="UVa" scheme="https://sandrala0413.git/categories/UVa/"/>
    
    
    <category term="Java" scheme="https://sandrala0413.git/tags/Java/"/>
    
    <category term="UVa-⭐" scheme="https://sandrala0413.git/tags/UVa-%E2%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>UVa 476 - Points in Figures： Rectangles</title>
    <link href="https://sandrala0413.git/post/UVA-476.html"/>
    <id>https://sandrala0413.git/post/UVA-476.html</id>
    <published>2025-05-03T01:13:42.000Z</published>
    <updated>2025-05-22T12:19:33.834Z</updated>
    
    <content type="html"><![CDATA[<h2 id="📘-題目簡述"><a href="#📘-題目簡述" class="headerlink" title="📘 題目簡述"></a>📘 題目簡述</h2><p>給定一個矩形圖形和 x-y 點的陣列，判斷點是否在圖形的範圍內</p><h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h3><p>Given a list of rectangles and a list of points in the x-y plane, determine for each point which figures<br>(if any) contain the point.</p><hr><h2 id="📥-輸入格式"><a href="#📥-輸入格式" class="headerlink" title="📥 輸入格式"></a>📥 輸入格式</h2><ul><li>矩形list：最多 n &lt;&#x3D; 10 個矩形描述，一行一個。第一個字元為 <em>r</em> ，代表矩形，後面跟著四個實數，代表左上和右下的座標。list 結束以星號表示</li><li>test list：一行一個 x-y 測試座標，需判斷該座標是否在圖形內(在圖形邊界上不算)。list 結束以 9999.99 9999.99表示(不包含在測試座標內)</li></ul><hr><h2 id="📤-輸出格式"><a href="#📤-輸出格式" class="headerlink" title="📤 輸出格式"></a>📤 輸出格式</h2><p>輸出<br><strong>Point i is contained in figure j</strong><br>or<br><strong>Point i is not contained in figure j</strong></p><hr><h2 id="🧠-判斷關鍵字出現規則"><a href="#🧠-判斷關鍵字出現規則" class="headerlink" title="🧠 判斷關鍵字出現規則"></a>🧠 判斷關鍵字出現規則</h2><ul><li><strong>不分大小寫比對</strong></li><li><strong>只比對整個單字</strong>，不能是字的一部分，例如：<ul><li>關鍵字 <code>dog</code>，在 <code>dog.</code>、<code>my-dog</code>、<code>dog!</code> 都算</li><li>在 <code>doggie</code> 中則不算</li></ul></li></ul><hr><h2 id="📌-題目範例輸入"><a href="#📌-題目範例輸入" class="headerlink" title="📌 題目範例輸入"></a>📌 題目範例輸入</h2><p>r 8.5 17.0 25.5 -8.5<br>r 0.0 10.3 5.5 0.0<br>r 2.5 12.5 12.5 2.5<br>*<br>2.0 2.0<br>4.7 5.3<br>6.9 11.2<br>20.0 20.0<br>17.6 3.2<br>-5.2 -7.8<br>9999.9 9999.9</p><hr><h2 id="📌-題目範例輸出"><a href="#📌-題目範例輸出" class="headerlink" title="📌 題目範例輸出"></a>📌 題目範例輸出</h2><p>Point 1 is contained in figure 2<br>Point 2 is contained in figure 2<br>Point 2 is contained in figure 3<br>Point 3 is contained in figure 3<br>Point 4 is not contained in any figure<br>Point 5 is contained in figure 1<br>Point 6 is not contained in any figure</p><hr><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>直覺做</p><h2 id="Java程式碼實作"><a href="#Java程式碼實作" class="headerlink" title="Java程式碼實作"></a>Java程式碼實作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Scanner in = new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        double[][] rec = new double[10][4];</span><br><span class="line">        </span><br><span class="line">        int index = 0;</span><br><span class="line">        while(!in.next().equals(&quot;*&quot;))&#123;</span><br><span class="line">            rec[index][0] = in.nextDouble();</span><br><span class="line">            rec[index][1] = in.nextDouble();</span><br><span class="line">            rec[index][2] = in.nextDouble();</span><br><span class="line">            rec[index][3] = in.nextDouble();</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        index = 1;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            double x = in.nextDouble();</span><br><span class="line">            double y = in.nextDouble();</span><br><span class="line">            if(x == 9999.9 &amp;&amp; y == 9999.9)    break;</span><br><span class="line"></span><br><span class="line">            boolean contain = false;</span><br><span class="line">            for(int i = 0; i &lt; 10 ; i++)&#123;</span><br><span class="line">                if(x &gt; rec[i][0] &amp;&amp; x &lt; rec[i][2] &amp;&amp; y &lt; rec[i][1] &amp;&amp; y &gt; rec[i][3])&#123;</span><br><span class="line">                    contain = true;</span><br><span class="line">                    System.out.printf(&quot;Point %d is contained in figure %d\n&quot;, index, i + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(!contain)        System.out.printf(&quot;Point %d is not contained in any figure\n&quot;, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;📘-題目簡述&quot;&gt;&lt;a href=&quot;#📘-題目簡述&quot; class=&quot;headerlink&quot; title=&quot;📘 題目簡述&quot;&gt;&lt;/a&gt;📘 題目簡述&lt;/h2&gt;&lt;p&gt;給定一個矩形圖形和 x-y 點的陣列，判斷點是否在圖形的範圍內&lt;/p&gt;
&lt;h3 id=&quot;原文&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="UVa" scheme="https://sandrala0413.git/categories/UVa/"/>
    
    
    <category term="Java" scheme="https://sandrala0413.git/tags/Java/"/>
    
    <category term="UVa-⭐" scheme="https://sandrala0413.git/tags/UVa-%E2%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>UVa 458 - The Decoder</title>
    <link href="https://sandrala0413.git/post/UVA-458.html"/>
    <id>https://sandrala0413.git/post/UVA-458.html</id>
    <published>2025-05-03T01:13:35.000Z</published>
    <updated>2025-05-22T12:19:29.940Z</updated>
    
    <content type="html"><![CDATA[<p>這題真的無敵簡單，但原本我用 Java 寫，送進解題一直 Runntime error ，真的快把我搞瘋了，後來看到一篇文章分享也有遇到類似的情形，改用 C++ 寫就解決了…</p><h2 id="📘-題目簡述"><a href="#📘-題目簡述" class="headerlink" title="📘 題目簡述"></a>📘 題目簡述</h2><p>找出字串編碼的規則</p><hr><h2 id="📥-輸入格式"><a href="#📥-輸入格式" class="headerlink" title="📥 輸入格式"></a>📥 輸入格式</h2><ul><li>輸入多行亂碼字串</li></ul><h2 id="📤-輸出格式"><a href="#📤-輸出格式" class="headerlink" title="📤 輸出格式"></a>📤 輸出格式</h2><ul><li>輸出解碼後的字串</li></ul><h2 id="📌-題目範例輸入"><a href="#📌-題目範例輸入" class="headerlink" title="📌 題目範例輸入"></a>📌 題目範例輸入</h2><p>1JKJ’pz’{ol’{yhklthyr’vm’{ol’Jvu{yvs’Kh{h’Jvywvyh{pvu5<br>1PIT’pz’h’{yhklthyr’vm’{ol’Pu{lyuh{pvuhs’I|zpulzz’Thjopul’Jvywvyh{pvu5<br>1KLJ’pz’{ol’{yhklthyr’vm’{ol’Kpnp{hs’Lx|pwtlu{‘Jvywvyh{pvu5</p><h2 id="📌-題目範例輸出"><a href="#📌-題目範例輸出" class="headerlink" title="📌 題目範例輸出"></a>📌 題目範例輸出</h2><p>*CDC is the trademark of the Control Data Corporation.<br>*IBM is a trademark of the International Business Machine Corporation.<br>*DEC is the trademark of the Digital Equipment Corporation.</p><hr><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>只要稍微觀察就能發現解碼就是 Ascii code 編碼 -7</p><h2 id="C-程式碼實作"><a href="#C-程式碼實作" class="headerlink" title="C++程式碼實作"></a>C++程式碼實作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    string s;</span><br><span class="line"></span><br><span class="line">    while(cin &gt;&gt; s)&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        for(int i = 0; i &lt; s.length(); ++i)</span><br><span class="line">            ans += char(int(s[i] - 7));</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;這題真的無敵簡單，但原本我用 Java 寫，送進解題一直 Runntime error ，真的快把我搞瘋了，後來看到一篇文章分享也有遇到類似的情形，改用 C++ 寫就解決了…&lt;/p&gt;
&lt;h2 id=&quot;📘-題目簡述&quot;&gt;&lt;a href=&quot;#📘-題目簡述&quot; class=&quot;he</summary>
      
    
    
    
    <category term="UVa" scheme="https://sandrala0413.git/categories/UVa/"/>
    
    
    <category term="C++" scheme="https://sandrala0413.git/tags/C/"/>
    
    <category term="UVa-⭐" scheme="https://sandrala0413.git/tags/UVa-%E2%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>UVa 455 - Periodic Strings 解題紀錄</title>
    <link href="https://sandrala0413.git/post/UVA-455.html"/>
    <id>https://sandrala0413.git/post/UVA-455.html</id>
    <published>2025-05-03T01:13:30.000Z</published>
    <updated>2025-05-22T12:19:27.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="📘-題目簡述"><a href="#📘-題目簡述" class="headerlink" title="📘 題目簡述"></a>📘 題目簡述</h2><p>一個字串若能透過一個長度為 k 的字串所組成，則稱這個字串有「周期 k 」<br>e.g.”abcabcabcabc” 由 “abc” 組成，周期 3 ，也可由 “abcabc” 組成，周期 6<br>找出給定字串的最小周期</p><hr><h2 id="📥-輸入格式"><a href="#📥-輸入格式" class="headerlink" title="📥 輸入格式"></a>📥 輸入格式</h2><ul><li>第一行是一個整數 N ，代表有幾筆測資(後面跟著一行空白)</li><li>每筆側資是一個字串(長度 &lt;&#x3D; 80)，用空白行隔開</li></ul><h2 id="📤-輸出格式"><a href="#📤-輸出格式" class="headerlink" title="📤 輸出格式"></a>📤 輸出格式</h2><ul><li>輸出對應的最小周期，每個輸出之間也須用空白行隔開</li></ul><h2 id="📌-題目範例輸入"><a href="#📌-題目範例輸入" class="headerlink" title="📌 題目範例輸入"></a>📌 題目範例輸入</h2><p>1</p><p>HoHoHo</p><h2 id="📌-題目範例輸出"><a href="#📌-題目範例輸出" class="headerlink" title="📌 題目範例輸出"></a>📌 題目範例輸出</h2><p>2</p><hr><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>對字串長度 len 的字串的所有因數都進行檢查，對於每個可能的子字串(長度 k )，重複組合 len&#x2F;k 次，再跟原字串做比對看是否一樣</p><h2 id="Java程式碼實作"><a href="#Java程式碼實作" class="headerlink" title="Java程式碼實作"></a>Java程式碼實作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Scanner in = new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        int n = in.nextInt();</span><br><span class="line">        int index = 0;</span><br><span class="line">        while(index &lt; n)&#123;</span><br><span class="line">            in.nextLine();</span><br><span class="line">            in.nextLine();</span><br><span class="line"></span><br><span class="line">            String str = in.next();</span><br><span class="line">            int period = str.length();  //最差情況</span><br><span class="line">            int len = str.length();</span><br><span class="line">            for(int i = 1; i &lt;= len; i++)&#123;</span><br><span class="line">                if(len % i != 0)    continue;</span><br><span class="line"></span><br><span class="line">                String tmp = str.substring(0, i);</span><br><span class="line">                String tmp2 = &quot;&quot;;</span><br><span class="line">                for(int j = 0; j &lt; len / i; j++)&#123;</span><br><span class="line">                    tmp2 += tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                if(tmp2.equals(str))&#123;</span><br><span class="line">                    period = i;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(period);</span><br><span class="line">            if(index &lt; n - 1)   System.out.println(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;📘-題目簡述&quot;&gt;&lt;a href=&quot;#📘-題目簡述&quot; class=&quot;headerlink&quot; title=&quot;📘 題目簡述&quot;&gt;&lt;/a&gt;📘 題目簡述&lt;/h2&gt;&lt;p&gt;一個字串若能透過一個長度為 k 的字串所組成，則稱這個字串有「周期 k 」&lt;br&gt;e.g.”abca</summary>
      
    
    
    
    <category term="UVa" scheme="https://sandrala0413.git/categories/UVa/"/>
    
    
    <category term="Java" scheme="https://sandrala0413.git/tags/Java/"/>
    
    <category term="UVa-⭐" scheme="https://sandrala0413.git/tags/UVa-%E2%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>UVa 409 - Excuses, Excuses! 解題紀錄</title>
    <link href="https://sandrala0413.git/post/UVA-409.html"/>
    <id>https://sandrala0413.git/post/UVA-409.html</id>
    <published>2025-05-01T12:37:41.000Z</published>
    <updated>2025-05-22T12:19:24.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="📘-題目簡述"><a href="#📘-題目簡述" class="headerlink" title="📘 題目簡述"></a>📘 題目簡述</h2><p>Judge Ito 想找出藉口最多「爛藉口關鍵字」的藉口。每一組資料包含若干關鍵字與藉口，找出那些包含關鍵字最多次的藉口。</p><hr><h2 id="📥-輸入格式"><a href="#📥-輸入格式" class="headerlink" title="📥 輸入格式"></a>📥 輸入格式</h2><ul><li>每組關鍵字皆為全小寫、長度 1~20，且只有英文字母。</li><li>每行藉口最大長度為 70，內容可含任意大小寫字母、數字、空格與下列標點符號：<code>. , ! ?</code></li></ul><hr><h2 id="📤-輸出格式"><a href="#📤-輸出格式" class="headerlink" title="📤 輸出格式"></a>📤 輸出格式</h2><ul><li>每組輸出以 <code>Excuse Set #X</code> 為開頭，X 為組別編號（從 1 開始）。</li><li>然後印出 <strong>關鍵字出現最多次</strong>的藉口（可多個，順序不限）。</li><li>每組輸出之間需空一行。</li></ul><hr><h2 id="🧠-判斷關鍵字出現規則"><a href="#🧠-判斷關鍵字出現規則" class="headerlink" title="🧠 判斷關鍵字出現規則"></a>🧠 判斷關鍵字出現規則</h2><ul><li><strong>不分大小寫比對</strong></li><li><strong>只比對整個單字</strong>，不能是字的一部分，例如：<ul><li>關鍵字 <code>dog</code>，在 <code>dog.</code>、<code>my-dog</code>、<code>dog!</code> 都算</li><li>在 <code>doggie</code> 中則不算</li></ul></li></ul><hr><h2 id="📌-題目範例輸入"><a href="#📌-題目範例輸入" class="headerlink" title="📌 題目範例輸入"></a>📌 題目範例輸入</h2><p>5 3<br>dog<br>ate<br>homework<br>canary<br>died<br>My dog ate my homework.<br>Can you believe my dog died after eating my canary… AND MY HOMEWORK?<br>This excuse is so good that it contain 0 keywords.<br>6 5<br>superhighway<br>crazy<br>thermonuclear<br>bedroom<br>war<br>building<br>I am having a superhighway built in my bedroom.<br>I am actually crazy.<br>1234567890…..,,,,,0987654321?????!!!!!!<br>There was a thermonuclear war!<br>I ate my dog, my canary, and my homework … note outdated keywords?</p><hr><h2 id="📌-題目範例輸出"><a href="#📌-題目範例輸出" class="headerlink" title="📌 題目範例輸出"></a>📌 題目範例輸出</h2><p>Excuse Set #1<br>Can you believe my dog died after eating my canary… AND MY HOMEWORK?<br>Excuse Set #2<br>I am having a superhighway built in my bedroom.<br>There was a thermonuclear war!</p><h2 id="Java程式碼實作"><a href="#Java程式碼實作" class="headerlink" title="Java程式碼實作"></a>Java程式碼實作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Scanner in = new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        int index = 1;</span><br><span class="line">        while(in.hasNext())&#123;</span><br><span class="line">            int n = in.nextInt();   //# of keywords</span><br><span class="line">            int m = in.nextInt();   //# of excues</span><br><span class="line">            in.nextLine();</span><br><span class="line">            String[] keyword_list = new String[n];</span><br><span class="line">            String[] excue_list = new String[m];</span><br><span class="line">            </span><br><span class="line">            for(int i = 0; i &lt; n; i++)  keyword_list[i] = in.nextLine();</span><br><span class="line">            for(int i = 0; i &lt; m; i ++) excue_list[i] = in.nextLine();</span><br><span class="line"></span><br><span class="line">            int[] times = new int[m];</span><br><span class="line">            int max = -1;</span><br><span class="line">            for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">                int tmp = 0;</span><br><span class="line">                String[] str = excue_list[i].split(&quot;[^a-zA-Z]+&quot;);</span><br><span class="line">                for(int j = 0; j &lt; n; j ++)&#123;</span><br><span class="line">                    for(int k = 0; k &lt; str.length; k++)&#123;</span><br><span class="line">                        if(str[k].toLowerCase().equals(keyword_list[j]))&#123;</span><br><span class="line">                            tmp++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if(tmp &gt; max)   max = tmp;</span><br><span class="line">                times[i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            System.out.println(&quot;Excuse Set #&quot; + index);</span><br><span class="line">            for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">                if(times[i] == max)&#123;</span><br><span class="line">                    System.out.println(excue_list[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;📘-題目簡述&quot;&gt;&lt;a href=&quot;#📘-題目簡述&quot; class=&quot;headerlink&quot; title=&quot;📘 題目簡述&quot;&gt;&lt;/a&gt;📘 題目簡述&lt;/h2&gt;&lt;p&gt;Judge Ito 想找出藉口最多「爛藉口關鍵字」的藉口。每一組資料包含若干關鍵字與藉口，找出那些包</summary>
      
    
    
    
    <category term="UVa" scheme="https://sandrala0413.git/categories/UVa/"/>
    
    
    <category term="Java" scheme="https://sandrala0413.git/tags/Java/"/>
    
    <category term="UVa-⭐" scheme="https://sandrala0413.git/tags/UVa-%E2%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>UVa 401 - Palindromes 解題紀錄</title>
    <link href="https://sandrala0413.git/post/UVA-401.html"/>
    <id>https://sandrala0413.git/post/UVA-401.html</id>
    <published>2025-05-01T12:27:06.000Z</published>
    <updated>2025-05-22T12:19:21.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="🪞-字串分類問題筆記：Palindrome-與-Mirrored-String"><a href="#🪞-字串分類問題筆記：Palindrome-與-Mirrored-String" class="headerlink" title="🪞 字串分類問題筆記：Palindrome 與 Mirrored String"></a>🪞 字串分類問題筆記：Palindrome 與 Mirrored String</h1><h2 id="📌-題目說明"><a href="#📌-題目說明" class="headerlink" title="📌 題目說明"></a>📌 題目說明</h2><p>給定一組輸入字串，請判斷其屬於以下哪一類：</p><ul><li><strong>不是 Palindrome，也不是 Mirrored String</strong>：<br><code>-- is not a palindrome.</code></li><li><strong>是 Palindrome，但不是 Mirrored String</strong>：<br><code>-- is a regular palindrome.</code></li><li><strong>是 Mirrored String，但不是 Palindrome</strong>：<br><code>-- is a mirrored string.</code></li><li><strong>同時是 Palindrome 與 Mirrored String</strong>：<br><code>-- is a mirrored palindrome.</code></li></ul><hr><h2 id="🔁-名詞解釋"><a href="#🔁-名詞解釋" class="headerlink" title="🔁 名詞解釋"></a>🔁 名詞解釋</h2><table><thead><tr><th>名稱</th><th>說明</th><th>範例</th></tr></thead><tbody><tr><td><strong>Palindrome</strong></td><td>正反都一樣的字串</td><td><code>ABCDEDCBA</code></td></tr><tr><td><strong>Mirrored String</strong></td><td>把每個字元換成「對應的鏡像字元」，再反過來看仍等於原字串</td><td><code>3AIAE</code></td></tr><tr><td><strong>Mirrored Palindrome</strong></td><td>同時符合 Palindrome 和 Mirrored String</td><td><code>ATOYOTA</code></td></tr></tbody></table><hr><h2 id="🔄-鏡像字元對照表"><a href="#🔄-鏡像字元對照表" class="headerlink" title="🔄 鏡像字元對照表"></a>🔄 鏡像字元對照表</h2><table><thead><tr><th>字元</th><th>鏡像</th><th>字元</th><th>鏡像</th><th>字元</th><th>鏡像</th></tr></thead><tbody><tr><td>A</td><td>A</td><td>M</td><td>M</td><td>Y</td><td>Y</td></tr><tr><td>B</td><td></td><td>N</td><td></td><td>Z</td><td>5</td></tr><tr><td>C</td><td></td><td>O</td><td>O</td><td>1</td><td>1</td></tr><tr><td>D</td><td></td><td>P</td><td></td><td>2</td><td>S</td></tr><tr><td>E</td><td>3</td><td>Q</td><td></td><td>3</td><td>E</td></tr><tr><td>F</td><td></td><td>R</td><td></td><td>4</td><td></td></tr><tr><td>G</td><td></td><td>S</td><td>2</td><td>5</td><td>Z</td></tr><tr><td>H</td><td>H</td><td>T</td><td>T</td><td>6</td><td></td></tr><tr><td>I</td><td>I</td><td>U</td><td>U</td><td>7</td><td></td></tr><tr><td>J</td><td>L</td><td>V</td><td>V</td><td>8</td><td>8</td></tr><tr><td>K</td><td></td><td>W</td><td>W</td><td>9</td><td></td></tr><tr><td>L</td><td>J</td><td>X</td><td>X</td><td></td><td></td></tr></tbody></table><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>⚠️ 注意：<strong>0（零）不被視為合法字元，只接受 O（英文字母）</strong></p></blockquote><hr><h2 id="📌-題目輸入格式"><a href="#📌-題目輸入格式" class="headerlink" title="📌 題目輸入格式"></a>📌 題目輸入格式</h2><ul><li>每行輸入包含1-20個有效字元(不會有無效字元出現)</li><li>讀到EOF結束</li></ul><hr><h2 id="📌-題目範例輸入"><a href="#📌-題目範例輸入" class="headerlink" title="📌 題目範例輸入"></a>📌 題目範例輸入</h2><p>NOTAPALINDROME<br>ISAPALINILAPASI<br>2A3MEAS<br>ATOYOTA</p><h2 id="📌-題目範例輸出"><a href="#📌-題目範例輸出" class="headerlink" title="📌 題目範例輸出"></a>📌 題目範例輸出</h2><p>NOTAPALINDROME – is not a palindrome.</p><p>ISAPALINILAPASI – is a regular palindrome.</p><p>2A3MEAS – is a mirrored string.</p><p>ATOYOTA – is a mirrored palindrome.</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>⚠️ 注意：每個輸出之間後面都要空一行</p></blockquote><hr><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>直覺做</p><h3 id="step1-判斷是否為-Palindrome："><a href="#step1-判斷是否為-Palindrome：" class="headerlink" title="step1:判斷是否為 Palindrome："></a>step1:判斷是否為 Palindrome：</h3><ul><li>判斷字串正反是否相同即可。</li></ul><h3 id="step-2判斷是否為-Mirrored-String："><a href="#step-2判斷是否為-Mirrored-String：" class="headerlink" title="step:2判斷是否為 Mirrored String："></a>step:2判斷是否為 Mirrored String：</h3><ol><li>將每個字元換成其鏡像（若無對應則不合法）。</li><li>換完後反轉字串，看是否與原字串相同。</li></ol><h2 id="💻-Java-程式碼實作"><a href="#💻-Java-程式碼實作" class="headerlink" title="💻 Java 程式碼實作"></a>💻 Java 程式碼實作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        Map&lt;Character, Character&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Character&gt;();</span><br><span class="line">        map.put(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;A&#x27;</span>); map.put(<span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;H&#x27;</span>); map.put(<span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;I&#x27;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;L&#x27;</span>); map.put(<span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;J&#x27;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>); map.put(<span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;O&#x27;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;2&#x27;</span>); map.put(<span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;T&#x27;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;U&#x27;</span>); map.put(<span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;V&#x27;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;W&#x27;</span>); map.put(<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;X&#x27;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>); map.put(<span class="string">&#x27;Z&#x27;</span>, <span class="string">&#x27;5&#x27;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>); map.put(<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;S&#x27;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;E&#x27;</span>); map.put(<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;8&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(in.hasNext())&#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">p</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">m</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line"></span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(str);</span><br><span class="line">            <span class="keyword">if</span>(str.equals(str2.reverse().toString()))&#123;</span><br><span class="line">                p = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++)&#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">                <span class="type">char</span> <span class="variable">ch2</span> <span class="operator">=</span> str.charAt(str.length() - i - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(!map.containsKey(ch) || map.get(ch) != ch2)&#123;</span><br><span class="line">                    m = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(p &amp;&amp; m)          System.out.println(str + <span class="string">&quot; -- is a mirrored palindrome.&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p)     System.out.println(str + <span class="string">&quot; -- is a regular palindrome.&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m)    System.out.println(str + <span class="string">&quot; -- is a mirrored string.&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span>                System.out.println(str + <span class="string">&quot; -- is not a palindrome.&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;🪞-字串分類問題筆記：Palindrome-與-Mirrored-String&quot;&gt;&lt;a href=&quot;#🪞-字串分類問題筆記：Palindrome-與-Mirrored-String&quot; class=&quot;headerlink&quot; title=&quot;🪞 字串分類問題筆記：</summary>
      
    
    
    
    <category term="UVa" scheme="https://sandrala0413.git/categories/UVa/"/>
    
    
    <category term="Java" scheme="https://sandrala0413.git/tags/Java/"/>
    
    <category term="UVa-⭐" scheme="https://sandrala0413.git/tags/UVa-%E2%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>UVa 389 - Basically Speaking 解題紀錄</title>
    <link href="https://sandrala0413.git/post/UVA-389.html"/>
    <id>https://sandrala0413.git/post/UVA-389.html</id>
    <published>2025-04-29T19:43:21.000Z</published>
    <updated>2025-05-22T12:19:19.197Z</updated>
    
    <content type="html"><![CDATA[<h2 id="📝-題目簡介"><a href="#📝-題目簡介" class="headerlink" title="📝 題目簡介"></a>📝 題目簡介</h2><p>給定一個數字、一個來源進位（base-n）與一個目標進位（base-m），將該數字從來源進位轉換為目標進位，並輸出結果。若轉換後的結果超過 7 個字元，輸出 <code>ERROR</code>。</p><hr><h2 id="📌-題目輸入格式"><a href="#📌-題目輸入格式" class="headerlink" title="📌 題目輸入格式"></a>📌 題目輸入格式</h2><p>每組輸入包含：</p><ul><li>一個表示數字的字串 <code>str</code>（最多 7 個字元，可能包含 <code>0-9</code> 與 <code>A-Z</code>）</li><li>來源進位 <code>n</code>（2 ≤ n ≤ 16）</li><li>目標進位 <code>m</code>（2 ≤ m ≤ 16）</li></ul><hr><h2 id="📌-題目範例輸入"><a href="#📌-題目範例輸入" class="headerlink" title="📌 題目範例輸入"></a>📌 題目範例輸入</h2><p>1111000 2 10<br>1111000 2 16<br>2102101 3 10<br>2102101 3 15<br>12312 4 2<br>1A 15 2<br>ABCD 16 15<br>03 13 10</p><h2 id="📌-題目範例輸出"><a href="#📌-題目範例輸出" class="headerlink" title="📌 題目範例輸出"></a>📌 題目範例輸出</h2><p>120<br>78<br>1765<br>7CA<br>ERROR<br>11001<br>D071<br>3</p><hr><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>先換成十進制再換成目標進制</p><h2 id="💻-Java-程式碼實作"><a href="#💻-Java-程式碼實作" class="headerlink" title="💻 Java 程式碼實作"></a>💻 Java 程式碼實作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(in.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> in.next();</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();   <span class="comment">// base from</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> in.nextInt();   <span class="comment">// base to</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// convert to base 10</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++)&#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">                <span class="type">int</span> digit;</span><br><span class="line">                <span class="keyword">if</span>(ch &lt; <span class="string">&#x27;A&#x27;</span>)&#123; <span class="comment">// digit: &#x27;0&#x27;~&#x27;9&#x27;</span></span><br><span class="line">                    digit = ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123; <span class="comment">// letter: &#x27;A&#x27;~&#x27;F&#x27;</span></span><br><span class="line">                    digit = ch - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp = tmp * n + digit; <span class="comment">// 累積轉為十進位</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// convert to base m</span></span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">if</span>(tmp == <span class="number">0</span>)&#123;</span><br><span class="line">                str2.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(tmp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> tmp % m;</span><br><span class="line">                    <span class="type">char</span> ch;</span><br><span class="line">                    <span class="keyword">if</span>(digit &gt; <span class="number">9</span>)&#123;</span><br><span class="line">                        ch = (<span class="type">char</span>)(<span class="string">&#x27;A&#x27;</span> + digit - <span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        ch = (<span class="type">char</span>)(digit + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    str2.append(ch);</span><br><span class="line">                    tmp /= m;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(str2.length() &gt; <span class="number">7</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;  ERROR&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%7s\n&quot;</span>, str2.reverse());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;📝-題目簡介&quot;&gt;&lt;a href=&quot;#📝-題目簡介&quot; class=&quot;headerlink&quot; title=&quot;📝 題目簡介&quot;&gt;&lt;/a&gt;📝 題目簡介&lt;/h2&gt;&lt;p&gt;給定一個數字、一個來源進位（base-n）與一個目標進位（base-m），將該數字從來源進位轉換為目</summary>
      
    
    
    
    <category term="UVa" scheme="https://sandrala0413.git/categories/UVa/"/>
    
    
    <category term="Java" scheme="https://sandrala0413.git/tags/Java/"/>
    
    <category term="UVa-⭐" scheme="https://sandrala0413.git/tags/UVa-%E2%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>UVa 386 - Perfect Cubes 題目筆記</title>
    <link href="https://sandrala0413.git/post/UVA-386.html"/>
    <id>https://sandrala0413.git/post/UVA-386.html</id>
    <published>2025-04-29T18:28:19.000Z</published>
    <updated>2025-05-22T12:19:14.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="📝-題目簡介"><a href="#📝-題目簡介" class="headerlink" title="📝 題目簡介"></a>📝 題目簡介</h2><p>本題要求列出所有符合以下條件的整數組合 <code>(a, b, c, d)</code>：</p><p>a³ &#x3D; b³ + c³ + d³</p><p>條件限制如下：</p><ul><li><code>2 ≤ a ≤ 200</code></li><li><code>2 ≤ b ≤ c ≤ d &lt; a</code></li></ul><hr><h2 id="📌-題目範例輸出"><a href="#📌-題目範例輸出" class="headerlink" title="📌 題目範例輸出"></a>📌 題目範例輸出</h2><p>Cube &#x3D; 6, Triple &#x3D; (3,4,5)<br>Cube &#x3D; 12, Triple &#x3D; (6,8,10)<br>Cube &#x3D; 18, Triple &#x3D; (2,12,16)<br>Cube &#x3D; 18, Triple &#x3D; (9,12,15)<br>Cube &#x3D; 19, Triple &#x3D; (3,10,18)<br>Cube &#x3D; 20, Triple &#x3D; (7,14,17)<br>Cube &#x3D; 24, Triple &#x3D; (12,16,20)</p><hr><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>直覺、暴力破解</p><ol><li>遍歷 <code>a</code> 從 2 到 200</li><li>對於每個 <code>a</code>，計算 <code>a³</code></li><li>接著三層巢狀迴圈，遍歷 <code>b, c, d</code>：<ul><li>條件為 <code>b ≤ c ≤ d &lt; a</code></li><li>確保不重複排列（例如 (2,3,4) 和 (3,2,4) 都不會重複出現）</li></ul></li><li>若 <code>b³ + c³ + d³ == a³</code>，就輸出結果</li></ol><h2 id="💻-Java-程式碼實作"><a href="#💻-Java-程式碼實作" class="headerlink" title="💻 Java 程式碼實作"></a>💻 Java 程式碼實作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= <span class="number">200</span>; i++)&#123;         <span class="comment">// a</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">a3</span> <span class="operator">=</span> i*i*i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt; i; j++)&#123;         <span class="comment">// b</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j; k &lt; i; k++)&#123;     <span class="comment">// c</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> k; l &lt; i; l++)&#123; <span class="comment">// d</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> j*j*j + k*k*k + l*l*l;</span><br><span class="line">                        <span class="keyword">if</span>(a3 == tmp)&#123;</span><br><span class="line">                            System.out.printf(<span class="string">&quot;Cube = %d, Triple = (%d,%d,%d)\n&quot;</span>, i, j, k, l);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;            </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;📝-題目簡介&quot;&gt;&lt;a href=&quot;#📝-題目簡介&quot; class=&quot;headerlink&quot; title=&quot;📝 題目簡介&quot;&gt;&lt;/a&gt;📝 題目簡介&lt;/h2&gt;&lt;p&gt;本題要求列出所有符合以下條件的整數組合 &lt;code&gt;(a, b, c, d)&lt;/code&gt;：&lt;/p&gt;</summary>
      
    
    
    
    <category term="UVa" scheme="https://sandrala0413.git/categories/UVa/"/>
    
    
    <category term="Java" scheme="https://sandrala0413.git/tags/Java/"/>
    
    <category term="UVa-⭐" scheme="https://sandrala0413.git/tags/UVa-%E2%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>UVa 382 - Perfection 解題紀錄</title>
    <link href="https://sandrala0413.git/post/UVA_382.html"/>
    <id>https://sandrala0413.git/post/UVA_382.html</id>
    <published>2025-04-29T17:59:40.000Z</published>
    <updated>2025-05-22T12:18:54.964Z</updated>
    
    <content type="html"><![CDATA[<p>已經一年多沒考過CPE了，最近發現距離大三最後一次CPE只剩20天，突然一股幹勁想把分數衝高一點，偷偷立個Flag要堅持天天刷三題，嗚嗚這真的很難，大一的時候也就一天一題，我的程式能力太差了，加上現在大三事情真的多到爆炸:(<br>好了廢話結束 加油三三!!! </p><h2 id="📝-題目簡介"><a href="#📝-題目簡介" class="headerlink" title="📝 題目簡介"></a>📝 題目簡介</h2><p>UVA 382 的任務是判斷輸入的整數是否為：</p><ul><li><strong>PERFECT（完全數）</strong>：所有真因數的總和等於該數</li><li><strong>ABUNDANT（盈數）</strong>：總和大於該數</li><li><strong>DEFICIENT（虧數）</strong>：總和小於該數</li></ul><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><strong>真因數</strong>：除了自己以外的正整數因數（包含 1）</p></blockquote><hr><h2 id="📌-題目範例輸入"><a href="#📌-題目範例輸入" class="headerlink" title="📌 題目範例輸入"></a>📌 題目範例輸入</h2><p>15 28 6 56 60000 22 496 0</p><h2 id="📌-題目範例輸出"><a href="#📌-題目範例輸出" class="headerlink" title="📌 題目範例輸出"></a>📌 題目範例輸出</h2><p>PERFECTION OUTPUT<br>15 DEFICIENT<br>28 PERFECT<br>6 PERFECT<br>56 ABUNDANT<br>60000 ABUNDANT<br>22 DEFICIENT<br>496 PERFECT<br>END OF OUTPUT</p><hr><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>直覺做法</p><ol><li>連續讀入整數 <code>n</code>，直到遇到 <code>0</code> 為止（作為結束標記）</li><li>對每個 <code>n</code>：<ul><li>計算所有真因數（小於 <code>n</code> 且可整除 <code>n</code>）</li><li>將真因數加總</li><li>根據總和結果分類為：<ul><li><strong>PERFECT</strong></li><li><strong>ABUNDANT</strong></li><li><strong>DEFICIENT</strong></li></ul></li></ul></li><li>使用格式化輸出對齊（<code>%5d</code>）</li></ol><hr><h2 id="💻-Java-實作程式碼"><a href="#💻-Java-實作程式碼" class="headerlink" title="💻 Java 實作程式碼"></a>💻 Java 實作程式碼</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;PERFECTION OUTPUT&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> n / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= k; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">                    sum += i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(sum == n &amp;&amp; n != <span class="number">1</span>)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%5d  PERFECT&quot;</span>, n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; n)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%5d  ABUNDANT&quot;</span>, n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%5d  DEFICIENT&quot;</span>, n);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">            n = in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;END OF OUTPUT&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;已經一年多沒考過CPE了，最近發現距離大三最後一次CPE只剩20天，突然一股幹勁想把分數衝高一點，偷偷立個Flag要堅持天天刷三題，嗚嗚這真的很難，大一的時候也就一天一題，我的程式能力太差了，加上現在大三事情真的多到爆炸:(&lt;br&gt;好了廢話結束 加油三三!!! &lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="UVa" scheme="https://sandrala0413.git/categories/UVa/"/>
    
    
    <category term="Java" scheme="https://sandrala0413.git/tags/Java/"/>
    
    <category term="UVa-⭐" scheme="https://sandrala0413.git/tags/UVa-%E2%AD%90/"/>
    
  </entry>
  
</feed>
