{"title":"實作筆記｜c++ 實作 Nonogram 演算法","uid":"c7479201d38a7ba731c30ed9fbf27358","slug":"nonogram","date":"2025-05-11T15:54:11.000Z","updated":"2025-10-03T20:08:04.859Z","comments":true,"path":"api/articles/nonogram.json","keywords":null,"cover":"https://i.pinimg.com/1200x/97/75/71/977571cd90f67cbc22416bf3ce3106b2.jpg","content":"<p>之前高效能運算課堂時老師提到了一個蠻有趣的論文，是由陽明交大資工系吳毅成教授團隊發表的 —— <strong>An Efficient Approach to Solving Nonograms (Wu et al., 2013)</strong><br>內容主要是提出一個更快的演算法來處理 Nonogram（一種黑白格填點遊戲）裡的 line solving(一行一行解題)，再搭配幾個 Fully Probing (FP) 的小技巧，把能確定的格子盡量先塗掉，最後才交給 backtracking</p>\n<p>系上一直都有學長姊在研究這個領域，也贏了很多次TCGA、ICGA電腦對局研討會的Nonogram冠軍，因為看著蠻好玩的就好奇動手把論文的方法實作了一下，用的是TCGA的標準。本來以為是小插曲，沒想到後來意外成為我國科會大專生研究計畫的主題哈哈，這篇除了是實作筆記也當作我再一次整理整個演算法的思路</p>\n<p>我的程式是根據後面有提到的TCGA規則寫的，有興趣的也可以到 <a href=\"https://github.com/Sandrala0413/Nonogram-SimpleVersion\">github</a> 看看我的程式碼~~~</p>\n<hr>\n<h2 id=\"論文的核心想法\"><a href=\"#論文的核心想法\" class=\"headerlink\" title=\"論文的核心想法\"></a>論文的核心想法</h2><p>論文中的解題方法是屬於單格導向的解題模式(現在也有如我正在研究的區塊挪移、邏輯規則求解等其他方法)。裡面演算法主要分為三個部分：</p>\n<ol>\n<li>Propagate: 基於動態規劃，反覆對單行或列進行猜測求解，直至不再有進展</li>\n<li>Fully Probing(FP): 針對尚未求得解的格子，分別猜測填黑或填白，然後再執行Propagate，檢驗何者會與目前盤面及線索相衝突(則另一不會導致衝突者，就是正確的解答方向)，若兩者都不會導致衝突，則填黑和填白的擴展後盤面取交集，即是可新求得解的格子</li>\n<li>Backtracking: 最後再以回溯搜尋法來求得所有剩餘格子的解答(其中會再反覆用到前一部分的Fully Probing方法)</li>\n</ol>\n<h3 id=\"1-Line-Solving-Propagation-with-DP\"><a href=\"#1-Line-Solving-Propagation-with-DP\" class=\"headerlink\" title=\"1. Line Solving &amp; Propagation with DP\"></a>1. Line Solving &amp; Propagation with DP</h3><p>傳統做法大多靠規則（rule-based）或 SAT&#x2F;ILP 轉換，速度或正確性都有限。<br>這篇論文的重點是 <strong>DP line solving</strong>：針對一條 row&#x2F;col，快速判斷哪些格子一定是黑、一定是白。 </p>\n<p>論文中 DP 有幾個主要函數：  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Fix(i, j) -&gt; 迴圈，驗證Si是否有解(fixble)</span><br><span class=\"line\">Fix0(i, j) -&gt; 設si = 0(空白格)</span><br><span class=\"line\">Fix1(i, j) -&gt; 設si = 1(黑格)</span><br></pre></td></tr></table></figure>\n<p>完整pseudo code<br><img src=\"/../imgs/image8.jpg\" alt=\"image\"><br>其中</p>\n<ul>\n<li>s[i] &#x3D; line 的第 i 個 cell 狀態（0 &#x3D; 白, 1 &#x3D; 黑, u &#x3D; 未知）</li>\n<li>d[j] &#x3D; 第 j 個 clue 的黑塊長度</li>\n<li>σ(d[j]) &#x3D; 長度為 d[j] 的黑塊 pattern（連續 d[j] 個黑格）</li>\n<li>segment(s[i]-d[j] .. s[i]) &#x3D; 從 i-d[j] 到 i 的 substring</li>\n</ul>\n<p>Fix(l, k) 時間複雜度是 <strong>O(kl)</strong></p>\n<h4 id=\"The-line-solving-problem：找到S的maximal-painting-S’\"><a href=\"#The-line-solving-problem：找到S的maximal-painting-S’\" class=\"headerlink\" title=\"The line-solving problem：找到S的maximal painting S’\"></a>The line-solving problem：找到S的maximal painting S’</h4><p>這裡的S &#x3D; s<del>1</del>s<del>2</del> … s<del>l</del>，代表該line和線索相符的string，S’則是S朝解更進一步的記號，所以這個部分的目標就是找到S最大的解(也就是全部都被標記上0、1、u，且符合線索)</p>\n<p>論文裡用到的函數稱為Paint，跟前面的Fix差別在於，Fix是試試看這樣填會不會有錯，Paint是真正將解填進去格子(填了就不能返回)<br>Fix會以一整條line來看，呼叫Fix來判斷是否有解<br><img src=\"/../imgs/image9.jpg\" alt=\"image\"><br>主要用到的填點技術是<code>Merge</code>，當Fix0、Fix1都成立時，代表那個點填0 or 1都行，就可以取當下兩個盤面的交集點，也就是可以確定的解，其他則依然unknown</p>\n<p>Paint(l, k)時間複雜度為<strong>O(kl^2)</strong></p>\n<h4 id=\"Propagation：把row、col的線索拿出來更進一步解\"><a href=\"#Propagation：把row、col的線索拿出來更進一步解\" class=\"headerlink\" title=\"Propagation：把row、col的線索拿出來更進一步解\"></a>Propagation：把row、col的線索拿出來更進一步解</h4><p><img src=\"/../imgs/image10.png\" alt=\"image\"></p>\n<h3 id=\"2-Fully-Probing-FP\"><a href=\"#2-Fully-Probing-FP\" class=\"headerlink\" title=\"2. Fully Probing (FP)\"></a>2. Fully Probing (FP)</h3><p>光靠 DP，還是會留下很多「未知」格子。<br>FP 的概念就是：在propagate完後先隨便挑一格u，假裝猜其是黑&#x2F;白 → propagate檢查是否conflict → 看能不能推出新資訊。<br>論文裡面提出了三種FP演算法</p>\n<ul>\n<li><p>FP1：最簡單，逐格嘗試</p>\n</li>\n<li><p>FP2：加上「反推（contrapositive）」，推出更多隱含關係</p>\n</li>\n<li><p>FP3：進一步做類似 2-SAT 的關聯推理</p>\n</li>\n</ul>\n<p>一個簡單的 FP1 片段，有興趣的人可以去翻翻原論文：<br><img src=\"/../imgs/image11.png\" alt=\"image\"></p>\n<p><img src=\"/../imgs/image12.png\" alt=\"image\"><br>其中</p>\n<ul>\n<li>G<del>p,0</del>：猜p &#x3D; 0後的牌面</li>\n<li>G<del>p,1</del>：猜p &#x3D; 1後的牌面</li>\n</ul>\n<p>這邊的 PROBE 裡的<code>CONFLICT</code>不是代表無解，而是因為前面Backtracking時可能就猜錯了所以導致無解(因為Backtracking是同時猜測多個點)<br>而 FP1 中迴圈裡是否要有那個<code>break</code>也是一個可以探討的問題，因為多了這個break出去更新牌面是有可能增加更多解，但也可能會增加計算量導致效率變低</p>\n<h3 id=\"3-Backtracking-選點策略\"><a href=\"#3-Backtracking-選點策略\" class=\"headerlink\" title=\"3. Backtracking + 選點策略\"></a>3. Backtracking + 選點策略</h3><p>當 FP 再也解不出點，就得進入Backtracking回溯<br>這裡選<strong>哪一格來猜</strong>很重要，好的 heuristic 能大幅減少遞迴深度，所以選點策略也是Nonogram研究中值得拿出來探討的事，論文裡也提出了6種選點策略，有趣的是交大自己實測最快的選點策略跟我們系上學長姐實驗出來的完全不一樣，所以這個議題還是蠻好玩的<br><img src=\"/../imgs/image13.png\" alt=\"alt text\"></p>\n<h3 id=\"Nonogram競賽規則-TCGA\"><a href=\"#Nonogram競賽規則-TCGA\" class=\"headerlink\" title=\"Nonogram競賽規則(TCGA)\"></a>Nonogram競賽規則(TCGA)</h3><p>TCGA是台灣電腦對局研討會，每年大約5月時除了會發表電腦對局相關的研究成果，也會舉辦電腦對局競賽，其中就有一項是Nonogram，規則如下</p>\n<ul>\n<li>每題題目編號前有 <strong>$</strong> ，後面會跟著線索</li>\n<li>每個題目為25*25之大小Nonogram盤面，線索共有50行，前25行代表row的線索(上到下)，後25行代表col的線索(左到右)</li>\n<li>solution需存於25*25大小矩陣， <strong>0</strong> 代表空白格， <strong>1</strong> 代表黑格</li>\n<li>每個線索跟解之間需用TAB相隔</li>\n<li>所有程式都會跑在同一台電腦，且只能使用單顆CPU</li>\n<li>程式只能按照題目順序解題，不能跳題</li>\n<li>一個題目可能有多個解，只需解出其中一個就可以</li>\n</ul>\n","text":"之前高效能運算課堂時老師提到了一個蠻有趣的論文，是由陽明交大資工系吳毅成教授團隊發表的 —— An Efficient Approach to Solving ...","permalink":"/post/nonogram","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"實作紀錄","slug":"實作紀錄","count":1,"path":"api/categories/實作紀錄.json"}],"tags":[{"name":"Nonogram","slug":"Nonogram","count":1,"path":"api/tags/Nonogram.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AB%96%E6%96%87%E7%9A%84%E6%A0%B8%E5%BF%83%E6%83%B3%E6%B3%95\"><span class=\"toc-text\">論文的核心想法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-Line-Solving-Propagation-with-DP\"><span class=\"toc-text\">1. Line Solving &amp; Propagation with DP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#The-line-solving-problem%EF%BC%9A%E6%89%BE%E5%88%B0S%E7%9A%84maximal-painting-S%E2%80%99\"><span class=\"toc-text\">The line-solving problem：找到S的maximal painting S’</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Propagation%EF%BC%9A%E6%8A%8Arow%E3%80%81col%E7%9A%84%E7%B7%9A%E7%B4%A2%E6%8B%BF%E5%87%BA%E4%BE%86%E6%9B%B4%E9%80%B2%E4%B8%80%E6%AD%A5%E8%A7%A3\"><span class=\"toc-text\">Propagation：把row、col的線索拿出來更進一步解</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Fully-Probing-FP\"><span class=\"toc-text\">2. Fully Probing (FP)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-Backtracking-%E9%81%B8%E9%BB%9E%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">3. Backtracking + 選點策略</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Nonogram%E7%AB%B6%E8%B3%BD%E8%A6%8F%E5%89%87-TCGA\"><span class=\"toc-text\">Nonogram競賽規則(TCGA)</span></a></li></ol></li></ol>","author":{"name":"三三","slug":"blog-author","avatar":"https://i.imgur.com/zzSYOPK.jpg","link":"/","description":"一個努力學習技術的小小資工人","socials":{"github":"https://github.com/Sandrala0413","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"UVa 496 - Simply Subsets 解題紀錄","uid":"96b15b957aec68c6e206ab179f6d8ea3","slug":"uva-496","date":"2025-05-21T06:35:10.000Z","updated":"2025-05-22T12:19:51.173Z","comments":true,"path":"api/articles/uva-496.json","keywords":null,"cover":"https://i.pinimg.com/736x/84/95/5a/84955a83a5d6dfb2ce3b6bcd1b576728.jpg","text":"📘 題目簡述判斷集合之間的關係 📥 輸入格式每兩行輸入代表兩個 set ，第一個為 set A ，第二個為 set B 📤 輸出格式針對每對 set A 、 B...","permalink":"/post/uva-496","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"UVa","slug":"UVa","count":16,"path":"api/categories/UVa.json"}],"tags":[{"name":"Java","slug":"Java","count":15,"path":"api/tags/Java.json"},{"name":"UVa-⭐","slug":"UVa-⭐","count":13,"path":"api/tags/UVa-⭐.json"}],"author":{"name":"三三","slug":"blog-author","avatar":"https://i.imgur.com/zzSYOPK.jpg","link":"/","description":"一個努力學習技術的小小資工人","socials":{"github":"https://github.com/Sandrala0413","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"UVa 255 - Correct Move 解題紀錄","uid":"b96fbff16cb7e065a8d2f5e9a45ac26c","slug":"uva-255","date":"2025-05-08T11:09:19.000Z","updated":"2025-09-24T20:43:05.510Z","comments":true,"path":"api/articles/uva-255.json","keywords":null,"cover":"https://i.pinimg.com/736x/6f/c4/90/6fc490be1996aaf3177a6c9e19d5bd00.jpg","text":"這題其實不難，就是讀題目讀的我很煩…英文能力仍需加強阿三三 📝 題目簡介有一個 8x8 的棋盤，總共有 64 格位置，編號從 0 到 63。棋盤上有兩個棋子：國...","permalink":"/post/uva-255","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"UVa","slug":"UVa","count":16,"path":"api/categories/UVa.json"}],"tags":[{"name":"Java","slug":"Java","count":15,"path":"api/tags/Java.json"},{"name":"UVa-⭐⭐","slug":"UVa-⭐⭐","count":3,"path":"api/tags/UVa-⭐⭐.json"}],"author":{"name":"三三","slug":"blog-author","avatar":"https://i.imgur.com/zzSYOPK.jpg","link":"/","description":"一個努力學習技術的小小資工人","socials":{"github":"https://github.com/Sandrala0413","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}