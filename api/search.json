[{"id":"f6fb998cdf8b4b8d8fe38e630943d18b","title":"Intel VTune Profiler實作紀錄","content":"最近在研究 Nonogram 的過程中，有了幾項有趣的發現：在執行系上高建壹學長撰寫的邏輯規則程式時，我的電腦不僅執行時間縮短了約 30%（應該是硬體效能差異），連 DFS 的呼叫次數也明顯減少。老師因此建議我使用 Profiling 工具VTune，檢測程式在不同階段的效能瓶頸，確認到底是哪個部分造成差異\n工具簡介Vtune是Intel出的Profiling工具，可以評估程式效能瓶頸，支援多種語言&#x2F;框架，包含c&#x2F;c++、java、python等，基本上主流的都可以，作業系統則支援Windows、Linux主流版本，最重要的是它有GUI圖形介面可以使用ㄛ!\n主要功能\nCPU&#x2F;演算法耗時分析(尋找Hotspots)\n自動統計程式中最耗時的函式、程式碼區塊或迴圈\n可檢視call stack(呼叫堆疊)與flame graph，幫助快速鎖定瓶頸\n\n\n記憶體&#x2F;快取分析(Memory access)\n計算cache命中率、記憶體頻寬使用率\n協助找出因cache miss或資料移動造成的延遲\n\n\n系統分析\n可針對特定功能、進程、時間段進行過濾分析\n支援CPU、GPU、FPGA與I&#x2F;O效能監測\n\n\n\n環境配置與安裝step 1：安裝intel oneAPIGet the Intel® oneAPI Base ToolkitVTune包含在oneAPI套件中，進到頁面選擇作業系統，還有一個選項是Offline&#x2F;Online installer，翻了網路上的文章好像都沒有說到這塊，問了一下AI，差別好像是在Online安裝時需要連線到Intel伺服器，優點是檔案比較小，因為可以客製化單獨挑選想要下載的元件；Offline的就不需網路，但檔案就大很多(因為他全部套件整包都包含在裡面)，\nLinux前往網站獲取下載指令，可以自行選擇安裝方式接著就能用下面指令打開offline installer的介面了(實際指令看下載頁面提供的，可能會依版本號不太一樣)\n12wget https://registrationcenter-download.intel.com/akdlm/IRC_NAS/3b7a16b3-a7b0-460f-be16-de0d64fa6b1e/intel-oneapi-base-toolkit-2025.2.1.44_offline.shsh intel-oneapi-base-toolkit-2025.2.1.44_offline.sh\nVTune使用的詳細指令可以看VTune command line Syntax\nWindows我這邊選擇的是Online\n下載好打開VTune Profiler，一進去他會導覽你去Help Tour，大概對整個的使用方法用一個範例簡單介紹，點New Project可以開始新增專案\n建立之後開始指定要分析的程式\n\nApplication：要分析的程式\nApplication parameters：執行時要加的命令列參數，不一定要\nWorking directory：指定程式執行時的工作目錄，像我這邊程式執行時需要餵txt給他，所以就指定根目錄\n\n按執行後VTune會產出性能快照，裡面包含Analysis tree，可以選擇接下來要詳細測試的類型，在這裡也可以觀察出最突出的效能瓶頸，會用紅色標註起來(像Hotspots圖標一樣)\n這邊遇到一個問題，在執行Hotspots分析時出現下面錯誤訊息，說是找不到sepdrv driver，但我檢查過是有安裝的，後來發現得用系統管理員身分打開VTune，就解決囉~\nstep 2：開始效能分析VTune有好幾種效能分析的方式：\n\n直連VTune啟動分析：打開VTune GUI，指定要分析的程式，或 在程式已經在跑的情況下，attach到該程式的進程，開始收集資料我一開始最直覺的想嘗試這個做法，網路上大多也是這樣，有興趣的人可以看一下我的研究過程，總之後來試到覺得太沒效率就放棄了嗚嗚:::spoiler try &amp; erorrrrrrrrrrrr 紀錄\n\n開始執行後遇到一個大問題：Cannot locate debugging information\n\n其實這樣也能正常執行，只是看不到詳細個別的function，剛開始我以為又是哪個driver沒有安裝好，查下發現以為是因為VTune得接收PDB符號(這個通常用於debug)才能將對應的符號對應到編譯程式中的標示符和指令，還因此走了一大段彎路想盡辦法產生.pdb，後來又看到這篇發問，完全就是我遇到的問題VTune does not show source file even with debugging info enabled\n沒想到在產生.pdb這個步驟我又大大的卡關了首先根據Intel doc有提供產生pdb的流程，但是是在Visual Studio IDE環境下(到現在我才知道原來這跟vs code不一樣)，vs code得手動在編譯時設定選項，而且得改成微軟家自己的MSVC編譯器，因此我就將原本的Makefile改成以下：\n12345# Compiler settingsCC = clCXXFLAGS = /O2 /Zi /EHsc /I$(INCdir)LDFLAGS = /DEBUGINCdir = include\n然後就開心的在CMD中make，卻又發現以下問題\n12process_begin: CreateProcess(NULL, cl /O2 /Zi /EHsc /Iinclude /c src/board.cpp /Foobj/board.obj, ...) failed.make (e=2): make: *** [makefile:36: obj/board.obj] Error 2\nAI說這是因為cl.exe 是 MSVC 編譯器，只存在於 Visual Studio &#x2F; Build Tools 安裝的 Developer Command Prompt 或 Native Tools Command Prompt，普通 shell 找不到路徑，所以 Make 無法執行 cl上網看了很多的資訊都是教如何在visual studio中安裝，或是資訊太久以前，後來發現visual studio code官方是有doc的，跟著做了一次終於可以了(淚目Configure VS Code for Microsoft C++:::\n\n先用 perf 工具收集，再匯入 VTune：先使用 Linux 的 perf（一個系統級效能分析工具）在命令列收集程式執行的效能事件與統計數據，生成報告檔（如 perf.data），接著打開 VTune，把這些檔案匯入，利用 GUI 做後續分析\n\n我這邊是用Intel編譯器執行VTune分析，最後再匯入，Windows GUI視覺化\n首先先載入VTune環境變數，如果不知道setvars.sh在哪可以先用指令找(通常在家目錄底下intel/oneapi/setvars.sh)\n1find ~/intel -name setvars.sh 2&gt;/dev/null\n載入環境變數\n1source &#123;你的路徑&#125;/intel/oneapi/setvars.sh\n可以用vtune -help測試是否載入成功\n接下來可以開始執行要分析的程式，注意程式在編譯時一定要帶-g才能帶debug info!!!開始分析指令\n12$ vtune -collect $COLLECTION_TYPE -r $RESULT_DIR $APPLICATION$APPLICATION_PARAMETERS\n\n$COLLECTION_TYPE：分析類型 (hotspots、memory-access、uarch-exploration 等)\n\n分析完會打包在剛剛指定的資料夾裡，如果你是連遠端機器可以用scp把資料傳輸回本地端，我是用wsl所以沒有這個問題\n點左側選單的資料夾載入剛剛的.vtune檔就可以開始看分析了~\n","slug":"VTune","date":"2025-09-24T05:18:12.000Z","categories_index":"","tags_index":"","author_index":"三三"},{"id":"2510e5cf9cf1d56df8292256586fa060","title":"nonogram","content":"","slug":"nonogram","date":"2025-09-11T15:54:11.000Z","categories_index":"","tags_index":"","author_index":"三三"},{"id":"bc9344032968b466e3512767cf2bb0ea","title":"Docker 新手初探筆記","content":"以前在學 Docker 時整理的筆記~之後再慢慢整理一些 Dockerfile、k8s 之類的放上來(๑•̀ㅁ•́๑)✧\nContainer v.s. VM為了增加硬體利用率，會在硬體層上建立一層虛擬化平台，並在平台中建立並運行多個虛擬機(VM)，彼此獨立並共享硬體資源。雖然如此能有效利用硬體資源，但每個VM都須擁有一個獨立的Guest OS，因此會造成幾個問題：\n\n佔據硬體資源：每個虛擬機都需要使用底層硬體資源建立Guest OS，佔據記憶體與硬碟空間，且還需透過Hypervisor進行虛擬機器與底層資源的溝通\n啟動時間漫長：由於每個VM都含有OS映像檔而導致過於肥大，因此建立和起動都需花費大量時間\n較低的可攜性：會因裝置、作業系統等環境的不同，導致無法執行VM中的應用程式\n\n容器化(Containerization)是一種連同硬體作業系統與運行服務做虛擬化的技術，讓運作在平台上的容器(Container)共享一個Host OS的資源。Container的目標是為了改善VM因Guest OS所導致的問題，所以Container以應用程式為主，包含應用程式與其所需的所有程式庫、環境設定、資料庫與網路設定等，每個Container都擁有完整的運行環境，不會受到其他應用程式或系統的影響，讓應用程式更容易移植和部屬到其他裝置或作業系統\n容器映像(Container Image)容器映像可理解為一個可執行的軟體包，是一個運行應用程式的環境，包含了可執行程式碼、支援程式庫、運算要求條件及所有依賴項，可以在不同平台運行。每個容器都需載入一個容器映像檔來執行。透過容器化技術，使用者只須將應用程式及相關依賴項打包到一個容器映像中，並指定所需的運行環境，就可以在Docker、Kubernetes等支援容器化技術的平台上運行。\nDockerDocker是一個開源的容器化平台，可以用來打包、運行和分享應用程式。Docker容器實現了應用程式的獨立性和可移植性，讓開發者和運維人員可以更加便捷地進行應用程式的開發、部署和運維。Docker映像檔包含執行軟體所需的一切功能：程式碼、程式執行環境、驅動程式、工具、程式庫、部屬等。Docker 容器是 Docker 映像檔的執行結果。不過，與虛擬機器管理程式的傳統虛擬化不同，Docker 容器會在主機作業系統的核心上執行。在 Docker 映像檔中，沒有如圖 1 所示的個別作業系統。\n優點：\n\n環境一致性：Docker可以將應用程式及其所有依賴項打包在一個容器中，確保從開發到測試到生產的整個生命週期中環境的一致性。\n輕量級、高性能：與傳統VM相比，Docker容器不須運行一整套OS，而是直接使用主機的OS，使得容器變得非常輕量且執行速度快。\n應用程式隔離：每個容器在其自己的容器中運行，有自己的網路和文件系統等，互不干擾，使得各種應用程式能在同一台機器上共存。\n可移植性：由於容器包含所有需要的依賴項，因此他可以在任何安裝了Docker的系統上運行(不論是在實體機or虛擬機、在數據中心or在雲端)\n易於管理和擴張：Docker提供豐富的工具和平台用於管理容器、服務等，使應用程式的部屬、擴展合為運變得簡單。\n\n主要功能：\n\n容器創建和管理：Docker提供創建、啟動、停止、移動和刪除容器的指令\n映像創建和分發：Docker可以創建容器映像，使其可被重複利用或移植到其他環境、分享給其他使用者。可實現應用程式快速部屬和擴展的基礎\n版本控制：Docker支援映像檔的版本控制\n資源隔離：每個 Docker 容器都有自己的檔案系統、自己的網路堆疊 (以及自己的 IP 位址)、自己的處理作業空間，以及針對 CPU 和記憶體定義的資源限制。由於 Docker 容器不需要啟動作業系統，因此會立即啟動。Docker 資源即隔離，例如將主機作業系統的資源隔離，而非虛擬化 (亦即VM提供Host OS系統的Guest OS系統)。\n資源整合：Docker可以將主機的資源如磁盤、網路和文件系統整合到容器中，使容器可以像真實的獨立系統一樣運行。\n\n","slug":"docker-introduction","date":"2025-05-22T12:11:12.000Z","categories_index":"資訊工程","tags_index":"Docker","author_index":"三三"},{"id":"d0fa460b3c567281dae195dbed83ee86","title":"UVa 499 - What's The Frequency, Kenneth? 解題紀錄","content":"CPE 考試小小經驗分享，其實多刷一星題練練手感，考試時就至少能答對三題了，一星題大多是考純 IO，少部分才需要用到一點 DP，二星三星也大多使用 DP (可能會一題內跑多個)，還有我在看題目的時候習慣直接看 IO ，真的不懂再回去看樂樂長的題目敘述~\n📘 題目簡述判斷句子中哪個字母出現頻率最高\n\n📤 輸出格式若最高頻率字母有多個，則按照字母順序，先大寫再小寫輸出\n📌 題目範例輸入When riding your bicycle backwards down a one-way street, if thewheel falls of a canoe, how many ball bearings does it take to fillup a water buffalo?Hello Howard.\n📌 題目範例輸出e 6al 7a 3Hlo 2\n\n解題思路直覺做，用一個 int 陣列紀錄每個字母出現的次數\nJava程式碼實作1234567891011121314151617181920212223242526272829303132333435363738import java.util.*;public class Main&#123;    public static void main(String[] args)&#123;        Scanner in = new Scanner(System.in);        while(in.hasNext())&#123;            int[] letter = new int[52];     //UpperCase：index 0~25；LowerCase：index 26~51            int max = 0;            String str = in.nextLine();            for(int i = 0; i &lt; str.length(); i++)&#123;                char ch = str.charAt(i);                if(ch &gt;= &#x27;A&#x27; &amp;&amp; ch &lt;= &#x27;Z&#x27;)&#123;                    letter[ch -&#x27;A&#x27;]++;                &#125;                else if(ch &gt;= &#x27;a&#x27; &amp;&amp; ch &lt;= &#x27;z&#x27;)&#123;                    letter[ch - &#x27;a&#x27; + 26]++;                &#125;            &#125;            for(int i = 0; i &lt; 52; i++)&#123;                if(letter[i] &gt; max)&#123;                    max = letter[i];                &#125;            &#125;                        for(int i = 0; i &lt; 52; i++)&#123;                if(letter[i] == max)&#123;                    if(i &lt; 26)  System.out.print((char)(i + &#x27;A&#x27;));                    else        System.out.print((char)(i - 26 + &#x27;a&#x27;));                &#125;            &#125;            System.out.print(&quot; &quot; + max + &quot;\\n&quot;);        &#125;    &#125;&#125;","slug":"uva-499","date":"2025-05-21T06:36:04.000Z","categories_index":"UVa","tags_index":"Java,UVa-⭐","author_index":"三三"},{"id":"6f1a16e6ffcb0b8c77d1999587882b50","title":"UVa 494 - Kindergarten Counting Game 解題紀錄","content":"夏天到了，把背景圖改成適合夏天的樣子(•̀ᴗ• )昨天 520 終於考完這次的 CPE ，戰績 3 題，達到了我預期中的目標但又有點小遺憾，當天再寫的時候寫完三題時間還綽綽有餘，看後面的題目也不難，結果卡在一個小 bug，但也已經比一年前的我進步很多了啦!前幾天太忙了，這幾天再慢慢努力把之前刷的題補上來~\n📘 題目簡述計算一行句子內有幾個 word\n\n📌 題目範例輸入Meep Meep!I tot I taw a putty tat.I did! I did! I did taw a putty tat.Shsssssssssh … I am hunting wabbits. Heh Heh Heh Heh …\n📌 題目範例輸出27109\n\n解題思路直覺做\nJava程式碼實作123456789101112131415161718192021222324import java.util.*;public class Main&#123;    public static void main(String[] args)&#123;        Scanner in = new Scanner(System.in);        while(in.hasNext())&#123;            String str = in.nextLine();            int count = 0;            boolean isWord = false;            for(int i = 0; i &lt; str.length();)&#123;                while(i &lt; str.length() &amp;&amp; Character.isLetter(str.charAt(i++)))&#123;                    isWord = true;                &#125;                if(isWord)  count++;                isWord = false;            &#125;            System.out.println(count);        &#125;    &#125;&#125;","slug":"uva-494","date":"2025-05-21T06:35:46.000Z","categories_index":"UVa","tags_index":"Java,UVa-⭐","author_index":"三三"},{"id":"96b15b957aec68c6e206ab179f6d8ea3","title":"UVa 496 - Simply Subsets 解題紀錄","content":"📘 題目簡述判斷集合之間的關係\n\n📥 輸入格式每兩行輸入代表兩個 set ，第一個為 set A ，第二個為 set B\n📤 輸出格式針對每對 set A 、 B 判斷是以下哪四個關係\n\nA is a proper subset of B\nB is a proper subset of A\nA equals B\nA and B are disjoint\nI’m confused!\n\n📌 題目範例輸入55 2755 279 24 19959 241 2 31 2 3 41 2 34 5 61 22 3\n📌 題目範例輸出A equals BB is a proper subset of AA is a proper subset of BA and B are disjointI’m confused!\n\n解題思路原本這題看到第一直覺是純手刻邏輯判斷，後來才發現 Java 有自帶判斷集合的 method\nJava程式碼實作12345678910111213141516171819202122232425262728import java.util.*;public class Main&#123;    public static void main(String[] args)&#123;        Scanner in = new Scanner(System.in);        while(in.hasNext())&#123;            Set&lt;Integer&gt; setA = new HashSet&lt;Integer&gt;();            Set&lt;Integer&gt; setB = new HashSet&lt;Integer&gt;();                        String tmp = in.nextLine();            for(String s: tmp.split(&quot; &quot;))&#123;                setA.add(Integer.valueOf(s));            &#125;            tmp = in.nextLine();            for(String s: tmp.split(&quot; &quot;))&#123;                setB.add(Integer.valueOf(s));            &#125;            if(setA.equals(setB))           System.out.println(&quot;A equals B&quot;);            else if(setA.containsAll(setB))    System.out.println(&quot;B is a proper subset of A&quot;);            else if(setB.containsAll(setA))    System.out.println(&quot;A is a proper subset of B&quot;);            else if(Collections.disjoint(setA, setB))   System.out.println(&quot;A and B are disjoint&quot;);            else                            System.out.println(&quot;I&#x27;m confused!&quot;);                             &#125;    &#125;&#125;","slug":"uva-496","date":"2025-05-21T06:35:10.000Z","categories_index":"UVa","tags_index":"Java,UVa-⭐","author_index":"三三"},{"id":"b96fbff16cb7e065a8d2f5e9a45ac26c","title":"UVa 255 - Correct Move 解題紀錄","content":"這題其實不難，就是讀題目讀的我很煩…英文能力仍需加強阿三三\n📝 題目簡介有一個 8x8 的棋盤，總共有 64 格位置，編號從 0 到 63。棋盤上有兩個棋子：國王 (King) 和 皇后 (Queen)。每次我們會給定一個棋盤狀態，其中包含國王和皇后的位置，以及皇后計算出的新位置\n\n\nlegal state：如果國王和皇后不在同一位置。\n\nlegal move：國王和皇后根據規則移動。\n\nallowed move：當國王和皇后移動後，它們不會移動到對方能夠移動到的位置。\n\n\n棋盤移動規則\nking：國王可以每次移動一格，方向是水平或垂直，不能到達皇后所在的位置\n\nqueen：皇后可以移動一格或多格，方向是水平或垂直，不能到達國王所在的位置\n\n禁止king、queen移動到同一位置\n\n\n\n📌 題目輸入格式\n每行包含三個整數，分別是國王、皇后和皇后計算出來的新位置（範圍為 0 至 63）\n\n需要判斷輸入是否符合上述條件\n\n\n📌 題目輸出格式\nIllegal state：如果國王和皇后在同一格上\n\nIllegal move：如果狀態是合法的，但皇后的移動不符合規則\n\nMove not allowed：如果狀態合法且皇后移動符合規則，但移動會使國王和皇后移動到對方的合法位置。\n\nContinue：如果國王和皇后移動後的狀態合法，並且國王仍然有合法的移動。\n\nStop：如果國王在移動後無法合法移動，處於被鎖死狀態。\n\n\n\n📌 題目範例輸入17 17 4917 49 5617 49 917 49 1717 49 2517 49 3317 49 4117 49 4956 48 49\n📌 題目範例輸出Illegal stateIllegal moveIllegal moveIllegal moveMove not allowedContinueContinueIllegal moveStop\n\n解題思路\n位置 % 8 可以得到 x 座標(左至右)\n位置 &#x2F; 8 可以得到 y 座標(上至下)\nstop 可以直接鎖死四個角來判斷，因為只有 king 在四個角時才有可能不能移動\n\n💻 Java 程式碼實作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.util.*;public class Main&#123;    public static boolean isBetween(int queen, int king, int queen2)&#123;        if(queen2 &gt; queen)&#123;            int tmp = queen2;            queen2 = queen;            queen = tmp;        &#125;        if(queen &gt; king &amp;&amp; king &gt; queen2)&#123;            return true;        &#125;        return false;    &#125;    public static void main(String[] args)&#123;        Scanner in = new Scanner(System.in);        while(in.hasNext())&#123;            int king = in.nextInt();            int queen = in.nextInt();            int queen2 = in.nextInt();            if(king == queen)&#123;                System.out.println(&quot;Illegal state&quot;);                continue;            &#125;            int kingX = king % 8;            int kingY = king / 8;            int queenX = queen % 8;            int queenY = queen / 8;            int queen2X = queen2 % 8;            int queen2Y = queen2 / 8;            boolean illegalMove = false;            if(queenX != queen2X &amp;&amp; queenY != queen2Y)&#123;     //queen moves diagonally                illegalMove = true;            &#125;            else if(queen == queen2 || queen2 == king)&#123;                      illegalMove = true;            &#125;            //queen2 across king            else if((queenX == kingX &amp;&amp; queenX == queen2X &amp;&amp; isBetween(queenY, kingY, queen2Y)) || (queenY == kingY &amp;&amp; queenY == queen2Y &amp;&amp; isBetween(queenX, kingX, queen2X)))&#123;                illegalMove = true;            &#125;            if(illegalMove)&#123;                System.out.println(&quot;Illegal move&quot;);                continue;            &#125;            if((king + 1 == queen2 &amp;&amp; queen2X != 0) || (king - 1 == queen2 &amp;&amp; queen2X != 7) || (king + 8 == queen2) || (king - 8 == queen2))&#123;                System.out.println(&quot;Move not allowed&quot;);                continue;            &#125;            if((queen2 == 9 &amp;&amp; king == 0) || (queen2 == 14 &amp;&amp; king == 7) || (queen2 == 49 &amp;&amp; king == 56) || (queen2 == 54 &amp;&amp; king == 63))&#123;                System.out.println(&quot;Stop&quot;);            &#125;            else&#123;                System.out.println(&quot;Continue&quot;);            &#125;        &#125;    &#125;&#125;\n\n\n碎碎念時間，好幾天沒練習了，上周六參加 PMI 專案管理競賽的台灣區決審，雖然技術層面上跟資工沒有太大的相關，但想著可以累積 PM 專案管理相關的經驗也不錯，還是投入很多心力在準備，為了這個比賽已經忙一個多月\n剛開始準備的時候真的完全摸不著頭緒，第一專案管理、商業分析啥的對一個純理工女真的太抽象嗚嗚，再來比賽規則可能是因為台灣區才第二年辦這個比賽，所以規則也不太明確，一下子說只需初審只需繳交十頁左右的計畫書，後來又說改成最多 60 頁的完整專案計畫書，我們也秉持著寫好寫滿的原則，狠狠的肝了許多 PMBOK 啥的專案管理的專業書籍，最後也寫出了 60 頁交出去初審，也順利進了決審，隔一週決審\n沒想到比寫專案計畫書還頭痛的事情來了，首先我們做的簡報真的醜的達咩爹斯，非常理工直男風，那個禮拜幾乎都在搞美編，真的把我美術細胞都榨乾了，後來又發現決審的簡報時間只有 15 分鐘，但我們整整有110 幾頁 ppt ，接著一天內的時間又緊急刪減了十幾頁，後來大家是用飆車的速度才順利講完\n比賽當天被告知 QA 是以同問同答的方式，我第一次體驗，還好當天比賽蠻順利的，隊友也給力，誰能想到比賽前一次練習我們都還沒壓縮好簡報時間呢，果然是需要一點腎上腺素爆發，結果也很幸運有進前三名，下個月就要代表台灣區比國際賽啦，祝我們繼續順利吧!!\n","slug":"uva-255","date":"2025-05-08T11:09:19.000Z","categories_index":"UVa","tags_index":"Java,UVa-⭐⭐","author_index":"三三"},{"id":"dc122d27be58fabbad4723eec95ffb99","title":"UVa 490 - Rotating Sentences 解題紀錄","content":"📘 題目簡述把輸入檔案由最後一行開始，由上至下轉置輸出\n\n📥 輸入格式給定最多 100 行 sentence ，每行不超過 100 個字元\n📤 輸出格式從最後一行由左至右垂直輸出\n📌 題目範例輸入Rene Decartes once said,“I think, therefore I am.”\n📌 題目範例輸出“RIentehiDnekc,arttheesreofnocreesIaiadm,.“\n\n解題思路直覺做，只要把每行輸入都用空白補成相同長度，輸出就很簡單了\nJava程式碼實作12345678910111213141516171819202122232425262728293031import java.util.*;public class Main&#123;    public static void main(String[] args)&#123;        Scanner in = new Scanner(System.in);        ArrayList&lt;String&gt; line = new ArrayList&lt;&gt;();        String tmp;        int max = 0;        while(in.hasNext())&#123;            tmp = in.nextLine();            line.add(tmp);            if(tmp.length() &gt; max)  max = tmp.length();        &#125;        for(int i = 0; i &lt; line.size(); i++)&#123;            tmp = line.get(i);            while(tmp.length() &lt; max)&#123;                tmp += &quot; &quot;;            &#125;            line.set(i, tmp);        &#125;        for(int i = 0; i &lt; max; i++)&#123;            for(int j = line.size() - 1; j &gt;= 0; j--)&#123;                System.out.print(line.get(j).charAt(i));            &#125;            System.out.println(&quot;&quot;);        &#125;    &#125;&#125;","slug":"uva-490","date":"2025-05-06T19:25:13.000Z","categories_index":"UVa","tags_index":"Java,UVa-⭐","author_index":"三三"},{"id":"078d103e26afc3a6eede6dcc8551ec6d","title":"UVa 245 Uncompress 解題紀錄","content":"📝 題目簡介把壓縮過的檔案還原，壓縮檔案包含 word 和數字，未壓縮檔沒有數字。壓縮檔中，若遇到先前沒有出現過的 word ，則將該 word 放到 list 的最前面(index 從 1 開始)；若遇到之前出現過的 word ，則用 list 中該 word 的 index 代替，並將該 word 移到 list 最前面；遇到非英文 or 數字的字元直接輸出\n\n📌 題目輸入格式\n沒有 word 超過 50 字元\n大小寫是有區分的\neg. abc 不等於 Abc\n\n\n輸入 0 時結束\n\n📌 題目輸出格式輸出解壓縮後的檔案\n📌 題目範例輸入Dear Sally,Please, please do it–1 would 4Mary very, 1 much. And 4 68 everything in 5’s power to make14 pay off for you.– Thank 2 18 18–0\n📌 題目範例輸出Dear Sally,Please, please do it–it would pleaseMary very, very much. And Mary woulddo everything in Mary’s power to makeit pay off for you.– Thank you very much–\n\n解題思路用 ArrayList&lt;&gt; 存取 list ，因為可以直接指定要拿取、刪除、新增的 index ，我覺得拿來實作這題很方便。當遇到字元是字母時就繼續讀取下去，存到字串中，直到讀取到不是字母的字元，再把該 word 存到 list 中；數字同理，存取到完整數字後轉為 index 到 list 中取出 word ，再把該 word 移到 list 最前面\n💻 Java 程式碼實作1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.*;public class Main&#123;    public static void main(String[] args)&#123;        Scanner in = new Scanner(System.in);        ArrayList&lt;String&gt; token = new ArrayList&lt;&gt;();        while(true)&#123;            String str = in.nextLine();            if(str.equals(&quot;0&quot;)) break;            String tmp = &quot;&quot;;            for(int i = 0; i &lt; str.length();)&#123;                char ch = str.charAt(i);                if(Character.isLetter(ch))&#123;                    while(i &lt; str.length() &amp;&amp; Character.isLetter(str.charAt(i)))&#123;                        tmp += str.charAt(i++);                    &#125;                    System.out.print(tmp);                    token.add(0, tmp);                    tmp = &quot;&quot;;                &#125;                else if(Character.isDigit(ch))&#123;                    int index = 0;                    while(i &lt; str.length() &amp;&amp; Character.isDigit(str.charAt(i)))&#123;                        index = index * 10 + str.charAt(i++) - &#x27;0&#x27;;                     &#125;                    String s = token.get(index-1);                    System.out.print(s);                    token.remove(index - 1);                    token.add(0, s);                &#125;                else&#123;                    System.out.print(ch);                    i++;                &#125;            &#125;            System.out.println(&quot;&quot;);        &#125;    &#125;&#125;","slug":"uva-245","date":"2025-05-06T19:25:04.000Z","categories_index":"UVa","tags_index":"Java,UVa-⭐⭐","author_index":"三三"},{"id":"21a63d82f0a9d51647bbd298764bba6d","title":"UVa 151 - Power Crisis 解題紀錄","content":"📝 題目簡介有編號 1~N 個能源廠，每次從第 1 個開始關閉，第 13 個最後關閉\n寫這個題目學到約瑟夫環(Josephus Problem)這個數學問題，這題是他的變形。傳統約瑟夫問題是由第 1 個人開始報數，報數到 3 的人就要自殺，再從下一個人重新報數，直到剩下一個倖存者。而這題是指定最後一個要存活的 index \n\n📌 題目輸入格式每行輸入代表此次 N 值，輸入為 0 時結束\n📌 題目輸出格式輸出能使編號 13 能源廠最後關閉的最小 m 值\n📌 題目範例輸入170\n📌 題目範例輸出7\n\n解題思路如果用直覺的作法，有 N 個能源廠，嘗試 m &#x3D; 1, 2, 3 …，每次模擬都要跑 N 輪，時間複雜度是 O(Nm)，但若用約瑟夫遞迴公式，可降到 O(N)\n\n公式：f(N, M) &#x3D; (f(N-1, M) + M) % N\nf(N, M)：N 個人，報數到 M 的人自殺時，最終活下來的人的編號\n\n\n\n\n\n\n\n\n注意：編號從 0 開始\n\n\n因為編號 1 能源廠一定第一個關閉，所以可視為只有 N-1 個能源廠在做約瑟夫問題，又因為公式 index 是從 0 開始，所以最後判斷的編號為 11\n💻 Java 程式碼實作12345678910111213141516171819202122232425import java.util.*;public class Main&#123;    public static void main(String[] args)&#123;        Scanner in = new Scanner(System.in);        int n = in.nextInt();        while(n != 0)&#123;            n--;        //always turn off number 1 first            int m = 1;            while(true)&#123;                int s = 0;                for(int j = 2; j &lt;= n; j++)&#123;                    s = (s + m) % j;                &#125;                if(s == 11) break;  //index 0~11                m++;            &#125;            System.out.println(m);            n = in.nextInt();        &#125;    &#125;&#125;","slug":"uva-151","date":"2025-05-05T14:24:40.000Z","categories_index":"UVa","tags_index":"Java,UVa-⭐⭐","author_index":"三三"},{"id":"f9c7209b1dac4f7544931dc13fc98f9a","title":"UVa 482 - Permutation Arrays","content":"📘 題目簡述給定一組浮點數陣列 x 和一個「索引排列陣列」 p ，要求依據排列陣列 p 將 x 中的資料重新排列\n\n📥 輸入格式\n第一行為一個整數，代表測資數，後面跟著一行空白\n每個測資包含兩行，測資間用空白行相隔\n第一行：index 陣列 p\n第二行：浮點數陣列\n\n\n\n📤 輸出格式\n將浮點數以 p 的順序重新排列後輸出，每個數字一行\n不能改變輸入格式\n不同測資間用空白行相隔\n\n📌 題目範例輸入1\n3 1 232.0 54.7 -2\n📌 題目範例輸出54.7-232.0\n\n解題思路直覺做，主要困難點於讀取輸入的部分，先用字串讀取一整行，再用 split() 分隔每個 token，這樣也能保留浮點數的格式\nJava程式碼實作123456789101112131415161718192021222324252627282930313233343536373839import java.util.*;public class Main&#123;    public static void main(String[] args)&#123;        Scanner in = new Scanner(System.in);        int n = in.nextInt();        in.nextLine();        in.nextLine();        for(int i = 0; i &lt; n; i ++)&#123;            String tmp = in.nextLine();             //read permutation array            String[] token1 = tmp.split(&quot; &quot;);            int[] p = new int[token1.length];            int length = p.length;            for(int j = 0; j &lt; length; j++)&#123;                p[j] = Integer.parseInt(token1[j]);            &#125;            tmp = in.nextLine();            String[] floatString = tmp.split(&quot; &quot;);            String[] ans = new String[length];            for(int j = 0; j &lt; length; j++)&#123;                ans[p[j] - 1] = floatString[j];            &#125;            for(int j = 0; j &lt; length; j++)&#123;                System.out.println(ans[j]);            &#125;            if(i &lt; n - 1)&#123;                System.out.println(&quot;&quot;);                in.nextLine();            &#125;                    &#125;    &#125;&#125;","slug":"UVA-482","date":"2025-05-03T02:56:33.000Z","categories_index":"UVa","tags_index":"Java,UVa-⭐","author_index":"三三"},{"id":"ba706da828ccf986444042ed05c48769","title":"UVa 476 - Points in Figures： Rectangles","content":"📘 題目簡述給定一個矩形圖形和 x-y 點的陣列，判斷點是否在圖形的範圍內\n原文Given a list of rectangles and a list of points in the x-y plane, determine for each point which figures(if any) contain the point.\n\n📥 輸入格式\n矩形list：最多 n &lt;&#x3D; 10 個矩形描述，一行一個。第一個字元為 r ，代表矩形，後面跟著四個實數，代表左上和右下的座標。list 結束以星號表示\ntest list：一行一個 x-y 測試座標，需判斷該座標是否在圖形內(在圖形邊界上不算)。list 結束以 9999.99 9999.99表示(不包含在測試座標內)\n\n\n📤 輸出格式輸出Point i is contained in figure jorPoint i is not contained in figure j\n\n🧠 判斷關鍵字出現規則\n不分大小寫比對\n只比對整個單字，不能是字的一部分，例如：\n關鍵字 dog，在 dog.、my-dog、dog! 都算\n在 doggie 中則不算\n\n\n\n\n📌 題目範例輸入r 8.5 17.0 25.5 -8.5r 0.0 10.3 5.5 0.0r 2.5 12.5 12.5 2.5*2.0 2.04.7 5.36.9 11.220.0 20.017.6 3.2-5.2 -7.89999.9 9999.9\n\n📌 題目範例輸出Point 1 is contained in figure 2Point 2 is contained in figure 2Point 2 is contained in figure 3Point 3 is contained in figure 3Point 4 is not contained in any figurePoint 5 is contained in figure 1Point 6 is not contained in any figure\n\n解題思路直覺做\nJava程式碼實作12345678910111213141516171819202122232425262728293031323334353637import java.util.*;public class Main&#123;    public static void main(String[] args)&#123;        Scanner in = new Scanner(System.in);        double[][] rec = new double[10][4];                int index = 0;        while(!in.next().equals(&quot;*&quot;))&#123;            rec[index][0] = in.nextDouble();            rec[index][1] = in.nextDouble();            rec[index][2] = in.nextDouble();            rec[index][3] = in.nextDouble();            index++;        &#125;        index = 1;        while(true)&#123;            double x = in.nextDouble();            double y = in.nextDouble();            if(x == 9999.9 &amp;&amp; y == 9999.9)    break;            boolean contain = false;            for(int i = 0; i &lt; 10 ; i++)&#123;                if(x &gt; rec[i][0] &amp;&amp; x &lt; rec[i][2] &amp;&amp; y &lt; rec[i][1] &amp;&amp; y &gt; rec[i][3])&#123;                    contain = true;                    System.out.printf(&quot;Point %d is contained in figure %d\\n&quot;, index, i + 1);                &#125;            &#125;            if(!contain)        System.out.printf(&quot;Point %d is not contained in any figure\\n&quot;, index);            index++;        &#125;    &#125;&#125;","slug":"UVA-476","date":"2025-05-03T01:13:42.000Z","categories_index":"UVa","tags_index":"Java,UVa-⭐","author_index":"三三"},{"id":"46852e72aa3a7adc78c339b32f53866f","title":"UVa 458 - The Decoder","content":"這題真的無敵簡單，但原本我用 Java 寫，送進解題一直 Runntime error ，真的快把我搞瘋了，後來看到一篇文章分享也有遇到類似的情形，改用 C++ 寫就解決了…\n📘 題目簡述找出字串編碼的規則\n\n📥 輸入格式\n輸入多行亂碼字串\n\n📤 輸出格式\n輸出解碼後的字串\n\n📌 題目範例輸入1JKJ’pz’{ol’{yhklthyr’vm’{ol’Jvu{yvs’Kh{h’Jvywvyh{pvu51PIT’pz’h’{yhklthyr’vm’{ol’Pu{lyuh{pvuhs’I|zpulzz’Thjopul’Jvywvyh{pvu51KLJ’pz’{ol’{yhklthyr’vm’{ol’Kpnp{hs’Lx|pwtlu{‘Jvywvyh{pvu5\n📌 題目範例輸出*CDC is the trademark of the Control Data Corporation.*IBM is a trademark of the International Business Machine Corporation.*DEC is the trademark of the Digital Equipment Corporation.\n\n解題思路只要稍微觀察就能發現解碼就是 Ascii code 編碼 -7\nC++程式碼實作123456789101112131415#include&lt;iostream&gt;using namespace std;int main()&#123;    string s;    while(cin &gt;&gt; s)&#123;        string ans;        for(int i = 0; i &lt; s.length(); ++i)            ans += char(int(s[i] - 7));        cout &lt;&lt; ans &lt;&lt; endl;    &#125;    return 0;&#125;","slug":"UVA-458","date":"2025-05-03T01:13:35.000Z","categories_index":"UVa","tags_index":"C++,UVa-⭐","author_index":"三三"},{"id":"9985901068632962fabcfe72f3ca1054","title":"UVa 455 - Periodic Strings 解題紀錄","content":"📘 題目簡述一個字串若能透過一個長度為 k 的字串所組成，則稱這個字串有「周期 k 」e.g.”abcabcabcabc” 由 “abc” 組成，周期 3 ，也可由 “abcabc” 組成，周期 6找出給定字串的最小周期\n\n📥 輸入格式\n第一行是一個整數 N ，代表有幾筆測資(後面跟著一行空白)\n每筆側資是一個字串(長度 &lt;&#x3D; 80)，用空白行隔開\n\n📤 輸出格式\n輸出對應的最小周期，每個輸出之間也須用空白行隔開\n\n📌 題目範例輸入1\nHoHoHo\n📌 題目範例輸出2\n\n解題思路對字串長度 len 的字串的所有因數都進行檢查，對於每個可能的子字串(長度 k )，重複組合 len&#x2F;k 次，再跟原字串做比對看是否一樣\nJava程式碼實作123456789101112131415161718192021222324252627282930313233343536import java.util.*;public class Main&#123;    public static void main(String[] args)&#123;        Scanner in = new Scanner(System.in);        int n = in.nextInt();        int index = 0;        while(index &lt; n)&#123;            in.nextLine();            in.nextLine();            String str = in.next();            int period = str.length();  //最差情況            int len = str.length();            for(int i = 1; i &lt;= len; i++)&#123;                if(len % i != 0)    continue;                String tmp = str.substring(0, i);                String tmp2 = &quot;&quot;;                for(int j = 0; j &lt; len / i; j++)&#123;                    tmp2 += tmp;                &#125;                if(tmp2.equals(str))&#123;                    period = i;                    break;                &#125;            &#125;            System.out.println(period);            if(index &lt; n - 1)   System.out.println(&quot;&quot;);            index++;        &#125;    &#125;&#125;","slug":"UVA-455","date":"2025-05-03T01:13:30.000Z","categories_index":"UVa","tags_index":"Java,UVa-⭐","author_index":"三三"},{"id":"10ba88f8de9eb376c0792a6be634516e","title":"UVa 409 - Excuses, Excuses! 解題紀錄","content":"📘 題目簡述Judge Ito 想找出藉口最多「爛藉口關鍵字」的藉口。每一組資料包含若干關鍵字與藉口，找出那些包含關鍵字最多次的藉口。\n\n📥 輸入格式\n每組關鍵字皆為全小寫、長度 1~20，且只有英文字母。\n每行藉口最大長度為 70，內容可含任意大小寫字母、數字、空格與下列標點符號：. , ! ?\n\n\n📤 輸出格式\n每組輸出以 Excuse Set #X 為開頭，X 為組別編號（從 1 開始）。\n然後印出 關鍵字出現最多次的藉口（可多個，順序不限）。\n每組輸出之間需空一行。\n\n\n🧠 判斷關鍵字出現規則\n不分大小寫比對\n只比對整個單字，不能是字的一部分，例如：\n關鍵字 dog，在 dog.、my-dog、dog! 都算\n在 doggie 中則不算\n\n\n\n\n📌 題目範例輸入5 3dogatehomeworkcanarydiedMy dog ate my homework.Can you believe my dog died after eating my canary… AND MY HOMEWORK?This excuse is so good that it contain 0 keywords.6 5superhighwaycrazythermonuclearbedroomwarbuildingI am having a superhighway built in my bedroom.I am actually crazy.1234567890…..,,,,,0987654321?????!!!!!!There was a thermonuclear war!I ate my dog, my canary, and my homework … note outdated keywords?\n\n📌 題目範例輸出Excuse Set #1Can you believe my dog died after eating my canary… AND MY HOMEWORK?Excuse Set #2I am having a superhighway built in my bedroom.There was a thermonuclear war!\nJava程式碼實作123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.*;public class Main&#123;    public static void main(String[] args)&#123;        Scanner in = new Scanner(System.in);        int index = 1;        while(in.hasNext())&#123;            int n = in.nextInt();   //# of keywords            int m = in.nextInt();   //# of excues            in.nextLine();            String[] keyword_list = new String[n];            String[] excue_list = new String[m];                        for(int i = 0; i &lt; n; i++)  keyword_list[i] = in.nextLine();            for(int i = 0; i &lt; m; i ++) excue_list[i] = in.nextLine();            int[] times = new int[m];            int max = -1;            for(int i = 0; i &lt; m; i++)&#123;                int tmp = 0;                String[] str = excue_list[i].split(&quot;[^a-zA-Z]+&quot;);                for(int j = 0; j &lt; n; j ++)&#123;                    for(int k = 0; k &lt; str.length; k++)&#123;                        if(str[k].toLowerCase().equals(keyword_list[j]))&#123;                            tmp++;                        &#125;                    &#125;                &#125;                if(tmp &gt; max)   max = tmp;                times[i] = tmp;            &#125;                        System.out.println(&quot;Excuse Set #&quot; + index);            for(int i = 0; i &lt; m; i++)&#123;                if(times[i] == max)&#123;                    System.out.println(excue_list[i]);                &#125;            &#125;            System.out.println(&quot;&quot;);            index++;        &#125;    &#125;&#125;","slug":"UVA-409","date":"2025-05-01T12:37:41.000Z","categories_index":"UVa","tags_index":"Java,UVa-⭐","author_index":"三三"},{"id":"a4fa2a2e1237c12e48292e997a1a88de","title":"UVa 401 - Palindromes 解題紀錄","content":"🪞 字串分類問題筆記：Palindrome 與 Mirrored String📌 題目說明給定一組輸入字串，請判斷其屬於以下哪一類：\n\n不是 Palindrome，也不是 Mirrored String：-- is not a palindrome.\n是 Palindrome，但不是 Mirrored String：-- is a regular palindrome.\n是 Mirrored String，但不是 Palindrome：-- is a mirrored string.\n同時是 Palindrome 與 Mirrored String：-- is a mirrored palindrome.\n\n\n🔁 名詞解釋\n\n\n名稱\n說明\n範例\n\n\n\nPalindrome\n正反都一樣的字串\nABCDEDCBA\n\n\nMirrored String\n把每個字元換成「對應的鏡像字元」，再反過來看仍等於原字串\n3AIAE\n\n\nMirrored Palindrome\n同時符合 Palindrome 和 Mirrored String\nATOYOTA\n\n\n\n🔄 鏡像字元對照表\n\n\n字元\n鏡像\n字元\n鏡像\n字元\n鏡像\n\n\n\nA\nA\nM\nM\nY\nY\n\n\nB\n\nN\n\nZ\n5\n\n\nC\n\nO\nO\n1\n1\n\n\nD\n\nP\n\n2\nS\n\n\nE\n3\nQ\n\n3\nE\n\n\nF\n\nR\n\n4\n\n\n\nG\n\nS\n2\n5\nZ\n\n\nH\nH\nT\nT\n6\n\n\n\nI\nI\nU\nU\n7\n\n\n\nJ\nL\nV\nV\n8\n8\n\n\nK\n\nW\nW\n9\n\n\n\nL\nJ\nX\nX\n\n\n\n\n\n\n\n\n\n\n\n\n\n⚠️ 注意：0（零）不被視為合法字元，只接受 O（英文字母）\n\n📌 題目輸入格式\n每行輸入包含1-20個有效字元(不會有無效字元出現)\n讀到EOF結束\n\n\n📌 題目範例輸入NOTAPALINDROMEISAPALINILAPASI2A3MEASATOYOTA\n📌 題目範例輸出NOTAPALINDROME – is not a palindrome.\nISAPALINILAPASI – is a regular palindrome.\n2A3MEAS – is a mirrored string.\nATOYOTA – is a mirrored palindrome.\n\n\n\n\n\n\n\n\n\n⚠️ 注意：每個輸出之間後面都要空一行\n\n解題思路直覺做\nstep1:判斷是否為 Palindrome：\n判斷字串正反是否相同即可。\n\nstep:2判斷是否為 Mirrored String：\n將每個字元換成其鏡像（若無對應則不合法）。\n換完後反轉字串，看是否與原字串相同。\n\n💻 Java 程式碼實作1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.*;public class Main&#123;    public static void main(String[] args)&#123;        Scanner in = new Scanner(System.in);        Map&lt;Character, Character&gt; map = new HashMap&lt;Character, Character&gt;();        map.put(&#x27;A&#x27;, &#x27;A&#x27;); map.put(&#x27;E&#x27;, &#x27;3&#x27;);        map.put(&#x27;H&#x27;, &#x27;H&#x27;); map.put(&#x27;I&#x27;, &#x27;I&#x27;);        map.put(&#x27;J&#x27;, &#x27;L&#x27;); map.put(&#x27;L&#x27;, &#x27;J&#x27;);        map.put(&#x27;M&#x27;, &#x27;M&#x27;); map.put(&#x27;O&#x27;, &#x27;O&#x27;);        map.put(&#x27;S&#x27;, &#x27;2&#x27;); map.put(&#x27;T&#x27;, &#x27;T&#x27;);        map.put(&#x27;U&#x27;, &#x27;U&#x27;); map.put(&#x27;V&#x27;, &#x27;V&#x27;);        map.put(&#x27;W&#x27;, &#x27;W&#x27;); map.put(&#x27;X&#x27;, &#x27;X&#x27;);        map.put(&#x27;Y&#x27;, &#x27;Y&#x27;); map.put(&#x27;Z&#x27;, &#x27;5&#x27;);        map.put(&#x27;1&#x27;, &#x27;1&#x27;); map.put(&#x27;2&#x27;, &#x27;S&#x27;);        map.put(&#x27;3&#x27;, &#x27;E&#x27;); map.put(&#x27;5&#x27;, &#x27;Z&#x27;);        map.put(&#x27;8&#x27;, &#x27;8&#x27;);        while(in.hasNext())&#123;            boolean p = false;            boolean m = true;            String str = in.nextLine();            StringBuilder str2 = new StringBuilder(str);            if(str.equals(str2.reverse().toString()))&#123;                p = true;            &#125;            for(int i = 0; i &lt; str.length(); i++)&#123;                char ch = str.charAt(i);                char ch2 = str.charAt(str.length() - i - 1);                if(!map.containsKey(ch) || map.get(ch) != ch2)&#123;                    m = false;                    break;                &#125;            &#125;            if(p &amp;&amp; m)          System.out.println(str + &quot; -- is a mirrored palindrome.&quot;);            else if(p)     System.out.println(str + &quot; -- is a regular palindrome.&quot;);            else if(m)    System.out.println(str + &quot; -- is a mirrored string.&quot;);            else                System.out.println(str + &quot; -- is not a palindrome.&quot;);            System.out.println(&quot;&quot;);        &#125;    &#125;&#125;","slug":"UVA-401","date":"2025-05-01T12:27:06.000Z","categories_index":"UVa","tags_index":"Java,UVa-⭐","author_index":"三三"},{"id":"4b390c175c6b5ba1f50ee7c6ec90878f","title":"UVa 389 - Basically Speaking 解題紀錄","content":"📝 題目簡介給定一個數字、一個來源進位（base-n）與一個目標進位（base-m），將該數字從來源進位轉換為目標進位，並輸出結果。若轉換後的結果超過 7 個字元，輸出 ERROR。\n\n📌 題目輸入格式每組輸入包含：\n\n一個表示數字的字串 str（最多 7 個字元，可能包含 0-9 與 A-Z）\n來源進位 n（2 ≤ n ≤ 16）\n目標進位 m（2 ≤ m ≤ 16）\n\n\n📌 題目範例輸入1111000 2 101111000 2 162102101 3 102102101 3 1512312 4 21A 15 2ABCD 16 1503 13 10\n📌 題目範例輸出1207817657CAERROR11001D0713\n\n解題思路先換成十進制再換成目標進制\n💻 Java 程式碼實作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.*;public class Main&#123;    public static void main(String[] args)&#123;        Scanner in = new Scanner(System.in);        while(in.hasNext())&#123;            String str = in.next();            int n = in.nextInt();   // base from            int m = in.nextInt();   // base to            int tmp = 0;            // convert to base 10            for(int i = 0; i &lt; str.length(); i++)&#123;                char ch = str.charAt(i);                int digit;                if(ch &lt; &#x27;A&#x27;)&#123; // digit: &#x27;0&#x27;~&#x27;9&#x27;                    digit = ch - &#x27;0&#x27;;                &#125;                else&#123; // letter: &#x27;A&#x27;~&#x27;F&#x27;                    digit = ch - &#x27;A&#x27; + 10;                &#125;                tmp = tmp * n + digit; // 累積轉為十進位            &#125;            // convert to base m            StringBuilder str2 = new StringBuilder();            if(tmp == 0)&#123;                str2.append(&quot;0&quot;);            &#125;            else&#123;                while(tmp &gt; 0)&#123;                    int digit = tmp % m;                    char ch;                    if(digit &gt; 9)&#123;                        ch = (char)(&#x27;A&#x27; + digit - 10);                    &#125;                    else&#123;                        ch = (char)(digit + &#x27;0&#x27;);                    &#125;                    str2.append(ch);                    tmp /= m;                &#125;            &#125;            if(str2.length() &gt; 7)&#123;                System.out.println(&quot;  ERROR&quot;);            &#125;            else&#123;                System.out.printf(&quot;%7s\\n&quot;, str2.reverse());            &#125;        &#125;    &#125;&#125;","slug":"UVA-389","date":"2025-04-29T19:43:21.000Z","categories_index":"UVa","tags_index":"Java,UVa-⭐","author_index":"三三"},{"id":"448899ffc5865887ee582722a0e73a3d","title":"UVa 386 - Perfect Cubes 題目筆記","content":"📝 題目簡介本題要求列出所有符合以下條件的整數組合 (a, b, c, d)：\na³ &#x3D; b³ + c³ + d³\n條件限制如下：\n\n2 ≤ a ≤ 200\n2 ≤ b ≤ c ≤ d &lt; a\n\n\n📌 題目範例輸出Cube &#x3D; 6, Triple &#x3D; (3,4,5)Cube &#x3D; 12, Triple &#x3D; (6,8,10)Cube &#x3D; 18, Triple &#x3D; (2,12,16)Cube &#x3D; 18, Triple &#x3D; (9,12,15)Cube &#x3D; 19, Triple &#x3D; (3,10,18)Cube &#x3D; 20, Triple &#x3D; (7,14,17)Cube &#x3D; 24, Triple &#x3D; (12,16,20)\n\n解題思路直覺、暴力破解\n\n遍歷 a 從 2 到 200\n對於每個 a，計算 a³\n接著三層巢狀迴圈，遍歷 b, c, d：\n條件為 b ≤ c ≤ d &lt; a\n確保不重複排列（例如 (2,3,4) 和 (3,2,4) 都不會重複出現）\n\n\n若 b³ + c³ + d³ == a³，就輸出結果\n\n💻 Java 程式碼實作1234567891011121314151617181920import java.util.*;public class Main&#123;    public static void main(String[] args)&#123;                for (int i = 2; i &lt;= 200; i++)&#123;         // a            int a3 = i*i*i;            for(int j = 2; j &lt; i; j++)&#123;         // b                for(int k = j; k &lt; i; k++)&#123;     // c                    for(int l = k; l &lt; i; l++)&#123; // d                        int tmp = j*j*j + k*k*k + l*l*l;                        if(a3 == tmp)&#123;                            System.out.printf(&quot;Cube = %d, Triple = (%d,%d,%d)\\n&quot;, i, j, k, l);                        &#125;                    &#125;                &#125;                        &#125;          &#125;    &#125;&#125;","slug":"UVA-386","date":"2025-04-29T18:28:19.000Z","categories_index":"UVa","tags_index":"Java,UVa-⭐","author_index":"三三"},{"id":"fdc7f82054e3322894610c08b3e708c6","title":"UVa 382 - Perfection 解題紀錄","content":"已經一年多沒考過CPE了，最近發現距離大三最後一次CPE只剩20天，突然一股幹勁想把分數衝高一點，偷偷立個Flag要堅持天天刷三題，嗚嗚這真的很難，大一的時候也就一天一題，我的程式能力太差了，加上現在大三事情真的多到爆炸:(好了廢話結束 加油三三!!! \n📝 題目簡介UVA 382 的任務是判斷輸入的整數是否為：\n\nPERFECT（完全數）：所有真因數的總和等於該數\nABUNDANT（盈數）：總和大於該數\nDEFICIENT（虧數）：總和小於該數\n\n\n\n\n\n\n\n\n\n\n真因數：除了自己以外的正整數因數（包含 1）\n\n📌 題目範例輸入15 28 6 56 60000 22 496 0\n📌 題目範例輸出PERFECTION OUTPUT15 DEFICIENT28 PERFECT6 PERFECT56 ABUNDANT60000 ABUNDANT22 DEFICIENT496 PERFECTEND OF OUTPUT\n\n解題思路直覺做法\n\n連續讀入整數 n，直到遇到 0 為止（作為結束標記）\n對每個 n：\n計算所有真因數（小於 n 且可整除 n）\n將真因數加總\n根據總和結果分類為：\nPERFECT\nABUNDANT\nDEFICIENT\n\n\n\n\n使用格式化輸出對齊（%5d）\n\n\n💻 Java 實作程式碼12345678910111213141516171819202122232425262728293031323334import java.util.*;public class Main&#123;    public static void main(String[] args)&#123;        Scanner in = new Scanner(System.in);        int n = in.nextInt();        System.out.println(&quot;PERFECTION OUTPUT&quot;);        while(n != 0)&#123;            int k = n / 2;            int sum = 1;            for(int i = 2; i &lt;= k; i++)&#123;                if(n % i == 0)&#123;                    sum += i;                &#125;            &#125;            if(sum == n &amp;&amp; n != 1)&#123;                System.out.printf(&quot;%5d  PERFECT&quot;, n);            &#125;            else if(sum &gt; n)&#123;                System.out.printf(&quot;%5d  ABUNDANT&quot;, n);            &#125;            else&#123;                System.out.printf(&quot;%5d  DEFICIENT&quot;, n);            &#125;            System.out.println(&quot;&quot;);            n = in.nextInt();        &#125;        System.out.println(&quot;END OF OUTPUT&quot;);    &#125;&#125;","slug":"UVA_382","date":"2025-04-29T17:59:40.000Z","categories_index":"UVa","tags_index":"Java,UVa-⭐","author_index":"三三"}]