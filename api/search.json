[{"id":"b96fbff16cb7e065a8d2f5e9a45ac26c","title":"UVa 255 - Correct Move 解題紀錄","content":"這題其實不難，就是讀題目讀的我很煩…英文能力仍需加強阿三三\n📝 題目簡介有一個 8x8 的棋盤，總共有 64 格位置，編號從 0 到 63。棋盤上有兩個棋子：國王 (King) 和 皇后 (Queen)。每次我們會給定一個棋盤狀態，其中包含國王和皇后的位置，以及皇后計算出的新位置\n\n\nlegal state：如果國王和皇后不在同一位置。\n\nlegal move：國王和皇后根據規則移動。\n\nallowed move：當國王和皇后移動後，它們不會移動到對方能夠移動到的位置。\n\n\n棋盤移動規則\nking：國王可以每次移動一格，方向是水平或垂直，不能到達皇后所在的位置\n\nqueen：皇后可以移動一格或多格，方向是水平或垂直，不能到達國王所在的位置\n\n禁止king、queen移動到同一位置\n\n\n\n📌 題目輸入格式\n每行包含三個整數，分別是國王、皇后和皇后計算出來的新位置（範圍為 0 至 63）\n\n需要判斷輸入是否符合上述條件\n\n\n📌 題目輸出格式\nIllegal state：如果國王和皇后在同一格上\n\nIllegal move：如果狀態是合法的，但皇后的移動不符合規則\n\nMove not allowed：如果狀態合法且皇后移動符合規則，但移動會使國王和皇后移動到對方的合法位置。\n\nContinue：如果國王和皇后移動後的狀態合法，並且國王仍然有合法的移動。\n\nStop：如果國王在移動後無法合法移動，處於被鎖死狀態。\n\n\n\n📌 題目範例輸入17 17 4917 49 5617 49 917 49 1717 49 2517 49 3317 49 4117 49 4956 48 49\n📌 題目範例輸出Illegal stateIllegal moveIllegal moveIllegal moveMove not allowedContinueContinueIllegal moveStop\n\n解題思路\n位置 % 8 可以得到 x 座標(左至右)\n位置 &#x2F; 8 可以得到 y 座標(上至下)\nstop 可以直接鎖死四個角來判斷，因為只有 king 在四個角時才有可能不能移動\n\n💻 Java 程式碼實作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.util.*;public class Main&#123;    public static boolean isBetween(int queen, int king, int queen2)&#123;        if(queen2 &gt; queen)&#123;            int tmp = queen2;            queen2 = queen;            queen = tmp;        &#125;        if(queen &gt; king &amp;&amp; king &gt; queen2)&#123;            return true;        &#125;        return false;    &#125;    public static void main(String[] args)&#123;        Scanner in = new Scanner(System.in);        while(in.hasNext())&#123;            int king = in.nextInt();            int queen = in.nextInt();            int queen2 = in.nextInt();            if(king == queen)&#123;                System.out.println(&quot;Illegal state&quot;);                continue;            &#125;            int kingX = king % 8;            int kingY = king / 8;            int queenX = queen % 8;            int queenY = queen / 8;            int queen2X = queen2 % 8;            int queen2Y = queen2 / 8;            boolean illegalMove = false;            if(queenX != queen2X &amp;&amp; queenY != queen2Y)&#123;     //queen moves diagonally                illegalMove = true;            &#125;            else if(queen == queen2 || queen2 == king)&#123;                      illegalMove = true;            &#125;            //queen2 across king            else if((queenX == kingX &amp;&amp; queenX == queen2X &amp;&amp; isBetween(queenY, kingY, queen2Y)) || (queenY == kingY &amp;&amp; queenY == queen2Y &amp;&amp; isBetween(queenX, kingX, queen2X)))&#123;                illegalMove = true;            &#125;            if(illegalMove)&#123;                System.out.println(&quot;Illegal move&quot;);                continue;            &#125;            if((king + 1 == queen2 &amp;&amp; queen2X != 0) || (king - 1 == queen2 &amp;&amp; queen2X != 7) || (king + 8 == queen2) || (king - 8 == queen2))&#123;                System.out.println(&quot;Move not allowed&quot;);                continue;            &#125;            if((queen2 == 9 &amp;&amp; king == 0) || (queen2 == 14 &amp;&amp; king == 7) || (queen2 == 49 &amp;&amp; king == 56) || (queen2 == 54 &amp;&amp; king == 63))&#123;                System.out.println(&quot;Stop&quot;);            &#125;            else&#123;                System.out.println(&quot;Continue&quot;);            &#125;        &#125;    &#125;&#125;\n\n\n碎碎念時間，好幾天沒練習了，上周六參加 PMI 專案管理競賽的台灣區決審，雖然技術層面上跟資工沒有太大的相關，但想著可以累積 PM 專案管理相關的經驗也不錯，還是投入很多心力在準備，為了這個比賽已經忙一個多月\n剛開始準備的時候真的完全摸不著頭緒，第一專案管理、商業分析啥的對一個純理工女真的太抽象嗚嗚，再來比賽規則可能是因為台灣區才第二年辦這個比賽，所以規則也不太明確，一下子說只需初審只需繳交十頁左右的計畫書，後來又說改成最多 60 頁的完整專案計畫書，我們也秉持著寫好寫滿的原則，狠狠的肝了許多 PMBOK 啥的專案管理的專業書籍，最後也寫出了 60 頁交出去初審，也順利進了決審，隔一週決審\n沒想到比寫專案計畫書還頭痛的事情來了，首先我們做的簡報真的醜的達咩爹斯，非常理工直男風，那個禮拜幾乎都在搞美編，真的把我美術細胞都榨乾了，後來又發現決審的簡報時間只有 15 分鐘，但我們整整有110 幾頁 ppt ，接著一天內的時間又緊急刪減了十幾頁，後來大家是用飆車的速度才順利講完\n比賽當天被告知 QA 是以同問同答的方式，我第一次體驗，還好當天比賽蠻順利的，隊友也給力，誰能想到比賽前一次練習我們都還沒壓縮好簡報時間呢，果然是需要一點腎上腺素爆發，結果也很幸運有進前三名，下個月就要代表台灣區比國際賽啦，祝我們繼續順利吧!!\n","slug":"uva-255","date":"2025-05-08T11:09:19.000Z","categories_index":"UVa-⭐⭐","tags_index":"Java,UVa","author_index":"三三"},{"id":"dc122d27be58fabbad4723eec95ffb99","title":"UVa 490 - Rotating Sentences 解題紀錄","content":"📘 題目簡述把輸入檔案由最後一行開始，由上至下轉置輸出\n\n📥 輸入格式給定最多 100 行 sentence ，每行不超過 100 個字元\n📤 輸出格式從最後一行由左至右垂直輸出\n📌 題目範例輸入Rene Decartes once said,“I think, therefore I am.”\n📌 題目範例輸出“RIentehiDnekc,arttheesreofnocreesIaiadm,.“\n\n解題思路直覺做，只要把每行輸入都用空白補成相同長度，輸出就很簡單了\nJava程式碼實作12345678910111213141516171819202122232425262728293031import java.util.*;public class Main&#123;    public static void main(String[] args)&#123;        Scanner in = new Scanner(System.in);        ArrayList&lt;String&gt; line = new ArrayList&lt;&gt;();        String tmp;        int max = 0;        while(in.hasNext())&#123;            tmp = in.nextLine();            line.add(tmp);            if(tmp.length() &gt; max)  max = tmp.length();        &#125;        for(int i = 0; i &lt; line.size(); i++)&#123;            tmp = line.get(i);            while(tmp.length() &lt; max)&#123;                tmp += &quot; &quot;;            &#125;            line.set(i, tmp);        &#125;        for(int i = 0; i &lt; max; i++)&#123;            for(int j = line.size() - 1; j &gt;= 0; j--)&#123;                System.out.print(line.get(j).charAt(i));            &#125;            System.out.println(&quot;&quot;);        &#125;    &#125;&#125;","slug":"uva-490","date":"2025-05-06T19:25:13.000Z","categories_index":"UVa-⭐","tags_index":"Java,UVa","author_index":"三三"},{"id":"078d103e26afc3a6eede6dcc8551ec6d","title":"UVa 245 Uncompress 解題紀錄","content":"📝 題目簡介把壓縮過的檔案還原，壓縮檔案包含 word 和數字，未壓縮檔沒有數字。壓縮檔中，若遇到先前沒有出現過的 word ，則將該 word 放到 list 的最前面(index 從 1 開始)；若遇到之前出現過的 word ，則用 list 中該 word 的 index 代替，並將該 word 移到 list 最前面；遇到非英文 or 數字的字元直接輸出\n\n📌 題目輸入格式\n沒有 word 超過 50 字元\n大小寫是有區分的\neg. abc 不等於 Abc\n\n\n輸入 0 時結束\n\n📌 題目輸出格式輸出解壓縮後的檔案\n📌 題目範例輸入Dear Sally,Please, please do it–1 would 4Mary very, 1 much. And 4 68 everything in 5’s power to make14 pay off for you.– Thank 2 18 18–0\n📌 題目範例輸出Dear Sally,Please, please do it–it would pleaseMary very, very much. And Mary woulddo everything in Mary’s power to makeit pay off for you.– Thank you very much–\n\n解題思路用 ArrayList&lt;&gt; 存取 list ，因為可以直接指定要拿取、刪除、新增的 index ，我覺得拿來實作這題很方便。當遇到字元是字母時就繼續讀取下去，存到字串中，直到讀取到不是字母的字元，再把該 word 存到 list 中；數字同理，存取到完整數字後轉為 index 到 list 中取出 word ，再把該 word 移到 list 最前面\n💻 Java 程式碼實作1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.*;public class Main&#123;    public static void main(String[] args)&#123;        Scanner in = new Scanner(System.in);        ArrayList&lt;String&gt; token = new ArrayList&lt;&gt;();        while(true)&#123;            String str = in.nextLine();            if(str.equals(&quot;0&quot;)) break;            String tmp = &quot;&quot;;            for(int i = 0; i &lt; str.length();)&#123;                char ch = str.charAt(i);                if(Character.isLetter(ch))&#123;                    while(i &lt; str.length() &amp;&amp; Character.isLetter(str.charAt(i)))&#123;                        tmp += str.charAt(i++);                    &#125;                    System.out.print(tmp);                    token.add(0, tmp);                    tmp = &quot;&quot;;                &#125;                else if(Character.isDigit(ch))&#123;                    int index = 0;                    while(i &lt; str.length() &amp;&amp; Character.isDigit(str.charAt(i)))&#123;                        index = index * 10 + str.charAt(i++) - &#x27;0&#x27;;                     &#125;                    String s = token.get(index-1);                    System.out.print(s);                    token.remove(index - 1);                    token.add(0, s);                &#125;                else&#123;                    System.out.print(ch);                    i++;                &#125;            &#125;            System.out.println(&quot;&quot;);        &#125;    &#125;&#125;","slug":"uva-245","date":"2025-05-06T19:25:04.000Z","categories_index":"UVa-⭐⭐","tags_index":"Java,UVa","author_index":"三三"},{"id":"21a63d82f0a9d51647bbd298764bba6d","title":"UVa 151 - Power Crisis 解題紀錄","content":"📝 題目簡介有編號 1~N 個能源廠，每次從第 1 個開始關閉，第 13 個最後關閉\n寫這個題目學到約瑟夫環(Josephus Problem)這個數學問題，這題是他的變形。傳統約瑟夫問題是由第 1 個人開始報數，報數到 3 的人就要自殺，再從下一個人重新報數，直到剩下一個倖存者。而這題是指定最後一個要存活的 index \n\n📌 題目輸入格式每行輸入代表此次 N 值，輸入為 0 時結束\n📌 題目輸出格式輸出能使編號 13 能源廠最後關閉的最小 m 值\n📌 題目範例輸入170\n📌 題目範例輸出7\n\n解題思路如果用直覺的作法，有 N 個能源廠，嘗試 m &#x3D; 1, 2, 3 …，每次模擬都要跑 N 輪，時間複雜度是 O(Nm)，但若用約瑟夫遞迴公式，可降到 O(N)\n\n公式：f(N, M) &#x3D; (f(N-1, M) + M) % N\nf(N, M)：N 個人，報數到 M 的人自殺時，最終活下來的人的編號\n\n\n\n\n\n\n\n\n注意：編號從 0 開始\n\n\n因為編號 1 能源廠一定第一個關閉，所以可視為只有 N-1 個能源廠在做約瑟夫問題，又因為公式 index 是從 0 開始，所以最後判斷的編號為 11\n💻 Java 程式碼實作12345678910111213141516171819202122232425import java.util.*;public class Main&#123;    public static void main(String[] args)&#123;        Scanner in = new Scanner(System.in);        int n = in.nextInt();        while(n != 0)&#123;            n--;        //always turn off number 1 first            int m = 1;            while(true)&#123;                int s = 0;                for(int j = 2; j &lt;= n; j++)&#123;                    s = (s + m) % j;                &#125;                if(s == 11) break;  //index 0~11                m++;            &#125;            System.out.println(m);            n = in.nextInt();        &#125;    &#125;&#125;","slug":"uva-151","date":"2025-05-05T14:24:40.000Z","categories_index":"UVa-⭐⭐","tags_index":"Java,UVa","author_index":"三三"},{"id":"f9c7209b1dac4f7544931dc13fc98f9a","title":"UVa 482 - Permutation Arrays","content":"📘 題目簡述給定一組浮點數陣列 x 和一個「索引排列陣列」 p ，要求依據排列陣列 p 將 x 中的資料重新排列\n\n📥 輸入格式\n第一行為一個整數，代表測資數，後面跟著一行空白\n每個測資包含兩行，測資間用空白行相隔\n第一行：index 陣列 p\n第二行：浮點數陣列\n\n\n\n📤 輸出格式\n將浮點數以 p 的順序重新排列後輸出，每個數字一行\n不能改變輸入格式\n不同測資間用空白行相隔\n\n📌 題目範例輸入1\n3 1 232.0 54.7 -2\n📌 題目範例輸出54.7-232.0\n\n解題思路直覺做，主要困難點於讀取輸入的部分，先用字串讀取一整行，再用 split() 分隔每個 token，這樣也能保留浮點數的格式\nJava程式碼實作123456789101112131415161718192021222324252627282930313233343536373839import java.util.*;public class Main&#123;    public static void main(String[] args)&#123;        Scanner in = new Scanner(System.in);        int n = in.nextInt();        in.nextLine();        in.nextLine();        for(int i = 0; i &lt; n; i ++)&#123;            String tmp = in.nextLine();             //read permutation array            String[] token1 = tmp.split(&quot; &quot;);            int[] p = new int[token1.length];            int length = p.length;            for(int j = 0; j &lt; length; j++)&#123;                p[j] = Integer.parseInt(token1[j]);            &#125;            tmp = in.nextLine();            String[] floatString = tmp.split(&quot; &quot;);            String[] ans = new String[length];            for(int j = 0; j &lt; length; j++)&#123;                ans[p[j] - 1] = floatString[j];            &#125;            for(int j = 0; j &lt; length; j++)&#123;                System.out.println(ans[j]);            &#125;            if(i &lt; n - 1)&#123;                System.out.println(&quot;&quot;);                in.nextLine();            &#125;                    &#125;    &#125;&#125;","slug":"UVA-482","date":"2025-05-03T02:56:33.000Z","categories_index":"UVa-⭐","tags_index":"Java,UVa","author_index":"三三"},{"id":"ba706da828ccf986444042ed05c48769","title":"UVa 476 - Points in Figures： Rectangles","content":"📘 題目簡述給定一個矩形圖形和 x-y 點的陣列，判斷點是否在圖形的範圍內\n原文Given a list of rectangles and a list of points in the x-y plane, determine for each point which figures(if any) contain the point.\n\n📥 輸入格式\n矩形list：最多 n &lt;&#x3D; 10 個矩形描述，一行一個。第一個字元為 r ，代表矩形，後面跟著四個實數，代表左上和右下的座標。list 結束以星號表示\ntest list：一行一個 x-y 測試座標，需判斷該座標是否在圖形內(在圖形邊界上不算)。list 結束以 9999.99 9999.99表示(不包含在測試座標內)\n\n\n📤 輸出格式輸出Point i is contained in figure jorPoint i is not contained in figure j\n\n🧠 判斷關鍵字出現規則\n不分大小寫比對\n只比對整個單字，不能是字的一部分，例如：\n關鍵字 dog，在 dog.、my-dog、dog! 都算\n在 doggie 中則不算\n\n\n\n\n📌 題目範例輸入r 8.5 17.0 25.5 -8.5r 0.0 10.3 5.5 0.0r 2.5 12.5 12.5 2.5*2.0 2.04.7 5.36.9 11.220.0 20.017.6 3.2-5.2 -7.89999.9 9999.9\n\n📌 題目範例輸出Point 1 is contained in figure 2Point 2 is contained in figure 2Point 2 is contained in figure 3Point 3 is contained in figure 3Point 4 is not contained in any figurePoint 5 is contained in figure 1Point 6 is not contained in any figure\n\n解題思路直覺做\nJava程式碼實作12345678910111213141516171819202122232425262728293031323334353637import java.util.*;public class Main&#123;    public static void main(String[] args)&#123;        Scanner in = new Scanner(System.in);        double[][] rec = new double[10][4];                int index = 0;        while(!in.next().equals(&quot;*&quot;))&#123;            rec[index][0] = in.nextDouble();            rec[index][1] = in.nextDouble();            rec[index][2] = in.nextDouble();            rec[index][3] = in.nextDouble();            index++;        &#125;        index = 1;        while(true)&#123;            double x = in.nextDouble();            double y = in.nextDouble();            if(x == 9999.9 &amp;&amp; y == 9999.9)    break;            boolean contain = false;            for(int i = 0; i &lt; 10 ; i++)&#123;                if(x &gt; rec[i][0] &amp;&amp; x &lt; rec[i][2] &amp;&amp; y &lt; rec[i][1] &amp;&amp; y &gt; rec[i][3])&#123;                    contain = true;                    System.out.printf(&quot;Point %d is contained in figure %d\\n&quot;, index, i + 1);                &#125;            &#125;            if(!contain)        System.out.printf(&quot;Point %d is not contained in any figure\\n&quot;, index);            index++;        &#125;    &#125;&#125;","slug":"UVA-476","date":"2025-05-03T01:13:42.000Z","categories_index":"UVa-⭐","tags_index":"Java,UVa","author_index":"三三"},{"id":"46852e72aa3a7adc78c339b32f53866f","title":"UVa 458 - The Decoder","content":"這題真的無敵簡單，但原本我用 Java 寫，送進解題一直 Runntime error ，真的快把我搞瘋了，後來看到一篇文章分享也有遇到類似的情形，改用 C++ 寫就解決了…\n📘 題目簡述找出字串編碼的規則\n\n📥 輸入格式\n輸入多行亂碼字串\n\n📤 輸出格式\n輸出解碼後的字串\n\n📌 題目範例輸入1JKJ’pz’{ol’{yhklthyr’vm’{ol’Jvu{yvs’Kh{h’Jvywvyh{pvu51PIT’pz’h’{yhklthyr’vm’{ol’Pu{lyuh{pvuhs’I|zpulzz’Thjopul’Jvywvyh{pvu51KLJ’pz’{ol’{yhklthyr’vm’{ol’Kpnp{hs’Lx|pwtlu{‘Jvywvyh{pvu5\n📌 題目範例輸出*CDC is the trademark of the Control Data Corporation.*IBM is a trademark of the International Business Machine Corporation.*DEC is the trademark of the Digital Equipment Corporation.\n\n解題思路只要稍微觀察就能發現解碼就是 Ascii code 編碼 -7\nC++程式碼實作123456789101112131415#include&lt;iostream&gt;using namespace std;int main()&#123;    string s;    while(cin &gt;&gt; s)&#123;        string ans;        for(int i = 0; i &lt; s.length(); ++i)            ans += char(int(s[i] - 7));        cout &lt;&lt; ans &lt;&lt; endl;    &#125;    return 0;&#125;","slug":"UVA-458","date":"2025-05-03T01:13:35.000Z","categories_index":"UVa-⭐","tags_index":"UVa,C++","author_index":"三三"},{"id":"9985901068632962fabcfe72f3ca1054","title":"UVa 455 - Periodic Strings 解題紀錄","content":"📘 題目簡述一個字串若能透過一個長度為 k 的字串所組成，則稱這個字串有「周期 k 」e.g.”abcabcabcabc” 由 “abc” 組成，周期 3 ，也可由 “abcabc” 組成，周期 6找出給定字串的最小周期\n\n📥 輸入格式\n第一行是一個整數 N ，代表有幾筆測資(後面跟著一行空白)\n每筆側資是一個字串(長度 &lt;&#x3D; 80)，用空白行隔開\n\n📤 輸出格式\n輸出對應的最小周期，每個輸出之間也須用空白行隔開\n\n📌 題目範例輸入1\nHoHoHo\n📌 題目範例輸出2\n\n解題思路對字串長度 len 的字串的所有因數都進行檢查，對於每個可能的子字串(長度 k )，重複組合 len&#x2F;k 次，再跟原字串做比對看是否一樣\nJava程式碼實作123456789101112131415161718192021222324252627282930313233343536import java.util.*;public class Main&#123;    public static void main(String[] args)&#123;        Scanner in = new Scanner(System.in);        int n = in.nextInt();        int index = 0;        while(index &lt; n)&#123;            in.nextLine();            in.nextLine();            String str = in.next();            int period = str.length();  //最差情況            int len = str.length();            for(int i = 1; i &lt;= len; i++)&#123;                if(len % i != 0)    continue;                String tmp = str.substring(0, i);                String tmp2 = &quot;&quot;;                for(int j = 0; j &lt; len / i; j++)&#123;                    tmp2 += tmp;                &#125;                if(tmp2.equals(str))&#123;                    period = i;                    break;                &#125;            &#125;            System.out.println(period);            if(index &lt; n - 1)   System.out.println(&quot;&quot;);            index++;        &#125;    &#125;&#125;","slug":"UVA-455","date":"2025-05-03T01:13:30.000Z","categories_index":"UVa-⭐","tags_index":"Java,UVa","author_index":"三三"},{"id":"10ba88f8de9eb376c0792a6be634516e","title":"UVa 409 - Excuses, Excuses! 解題紀錄","content":"📘 題目簡述Judge Ito 想找出藉口最多「爛藉口關鍵字」的藉口。每一組資料包含若干關鍵字與藉口，找出那些包含關鍵字最多次的藉口。\n\n📥 輸入格式\n每組關鍵字皆為全小寫、長度 1~20，且只有英文字母。\n每行藉口最大長度為 70，內容可含任意大小寫字母、數字、空格與下列標點符號：. , ! ?\n\n\n📤 輸出格式\n每組輸出以 Excuse Set #X 為開頭，X 為組別編號（從 1 開始）。\n然後印出 關鍵字出現最多次的藉口（可多個，順序不限）。\n每組輸出之間需空一行。\n\n\n🧠 判斷關鍵字出現規則\n不分大小寫比對\n只比對整個單字，不能是字的一部分，例如：\n關鍵字 dog，在 dog.、my-dog、dog! 都算\n在 doggie 中則不算\n\n\n\n\n📌 題目範例輸入5 3dogatehomeworkcanarydiedMy dog ate my homework.Can you believe my dog died after eating my canary… AND MY HOMEWORK?This excuse is so good that it contain 0 keywords.6 5superhighwaycrazythermonuclearbedroomwarbuildingI am having a superhighway built in my bedroom.I am actually crazy.1234567890…..,,,,,0987654321?????!!!!!!There was a thermonuclear war!I ate my dog, my canary, and my homework … note outdated keywords?\n\n📌 題目範例輸出Excuse Set #1Can you believe my dog died after eating my canary… AND MY HOMEWORK?Excuse Set #2I am having a superhighway built in my bedroom.There was a thermonuclear war!\nJava程式碼實作123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.*;public class Main&#123;    public static void main(String[] args)&#123;        Scanner in = new Scanner(System.in);        int index = 1;        while(in.hasNext())&#123;            int n = in.nextInt();   //# of keywords            int m = in.nextInt();   //# of excues            in.nextLine();            String[] keyword_list = new String[n];            String[] excue_list = new String[m];                        for(int i = 0; i &lt; n; i++)  keyword_list[i] = in.nextLine();            for(int i = 0; i &lt; m; i ++) excue_list[i] = in.nextLine();            int[] times = new int[m];            int max = -1;            for(int i = 0; i &lt; m; i++)&#123;                int tmp = 0;                String[] str = excue_list[i].split(&quot;[^a-zA-Z]+&quot;);                for(int j = 0; j &lt; n; j ++)&#123;                    for(int k = 0; k &lt; str.length; k++)&#123;                        if(str[k].toLowerCase().equals(keyword_list[j]))&#123;                            tmp++;                        &#125;                    &#125;                &#125;                if(tmp &gt; max)   max = tmp;                times[i] = tmp;            &#125;                        System.out.println(&quot;Excuse Set #&quot; + index);            for(int i = 0; i &lt; m; i++)&#123;                if(times[i] == max)&#123;                    System.out.println(excue_list[i]);                &#125;            &#125;            System.out.println(&quot;&quot;);            index++;        &#125;    &#125;&#125;","slug":"UVA-409","date":"2025-05-01T12:37:41.000Z","categories_index":"UVa-⭐","tags_index":"Java,UVa","author_index":"三三"},{"id":"a4fa2a2e1237c12e48292e997a1a88de","title":"UVa 401 - Palindromes 解題紀錄","content":"🪞 字串分類問題筆記：Palindrome 與 Mirrored String📌 題目說明給定一組輸入字串，請判斷其屬於以下哪一類：\n\n不是 Palindrome，也不是 Mirrored String：-- is not a palindrome.\n是 Palindrome，但不是 Mirrored String：-- is a regular palindrome.\n是 Mirrored String，但不是 Palindrome：-- is a mirrored string.\n同時是 Palindrome 與 Mirrored String：-- is a mirrored palindrome.\n\n\n🔁 名詞解釋\n\n\n名稱\n說明\n範例\n\n\n\nPalindrome\n正反都一樣的字串\nABCDEDCBA\n\n\nMirrored String\n把每個字元換成「對應的鏡像字元」，再反過來看仍等於原字串\n3AIAE\n\n\nMirrored Palindrome\n同時符合 Palindrome 和 Mirrored String\nATOYOTA\n\n\n\n🔄 鏡像字元對照表\n\n\n字元\n鏡像\n字元\n鏡像\n字元\n鏡像\n\n\n\nA\nA\nM\nM\nY\nY\n\n\nB\n\nN\n\nZ\n5\n\n\nC\n\nO\nO\n1\n1\n\n\nD\n\nP\n\n2\nS\n\n\nE\n3\nQ\n\n3\nE\n\n\nF\n\nR\n\n4\n\n\n\nG\n\nS\n2\n5\nZ\n\n\nH\nH\nT\nT\n6\n\n\n\nI\nI\nU\nU\n7\n\n\n\nJ\nL\nV\nV\n8\n8\n\n\nK\n\nW\nW\n9\n\n\n\nL\nJ\nX\nX\n\n\n\n\n\n\n\n\n\n\n\n\n\n⚠️ 注意：0（零）不被視為合法字元，只接受 O（英文字母）\n\n📌 題目輸入格式\n每行輸入包含1-20個有效字元(不會有無效字元出現)\n讀到EOF結束\n\n\n📌 題目範例輸入NOTAPALINDROMEISAPALINILAPASI2A3MEASATOYOTA\n📌 題目範例輸出NOTAPALINDROME – is not a palindrome.\nISAPALINILAPASI – is a regular palindrome.\n2A3MEAS – is a mirrored string.\nATOYOTA – is a mirrored palindrome.\n\n\n\n\n\n\n\n\n\n⚠️ 注意：每個輸出之間後面都要空一行\n\n解題思路直覺做\nstep1:判斷是否為 Palindrome：\n判斷字串正反是否相同即可。\n\nstep:2判斷是否為 Mirrored String：\n將每個字元換成其鏡像（若無對應則不合法）。\n換完後反轉字串，看是否與原字串相同。\n\n💻 Java 程式碼實作1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.*;public class Main&#123;    public static void main(String[] args)&#123;        Scanner in = new Scanner(System.in);        Map&lt;Character, Character&gt; map = new HashMap&lt;Character, Character&gt;();        map.put(&#x27;A&#x27;, &#x27;A&#x27;); map.put(&#x27;E&#x27;, &#x27;3&#x27;);        map.put(&#x27;H&#x27;, &#x27;H&#x27;); map.put(&#x27;I&#x27;, &#x27;I&#x27;);        map.put(&#x27;J&#x27;, &#x27;L&#x27;); map.put(&#x27;L&#x27;, &#x27;J&#x27;);        map.put(&#x27;M&#x27;, &#x27;M&#x27;); map.put(&#x27;O&#x27;, &#x27;O&#x27;);        map.put(&#x27;S&#x27;, &#x27;2&#x27;); map.put(&#x27;T&#x27;, &#x27;T&#x27;);        map.put(&#x27;U&#x27;, &#x27;U&#x27;); map.put(&#x27;V&#x27;, &#x27;V&#x27;);        map.put(&#x27;W&#x27;, &#x27;W&#x27;); map.put(&#x27;X&#x27;, &#x27;X&#x27;);        map.put(&#x27;Y&#x27;, &#x27;Y&#x27;); map.put(&#x27;Z&#x27;, &#x27;5&#x27;);        map.put(&#x27;1&#x27;, &#x27;1&#x27;); map.put(&#x27;2&#x27;, &#x27;S&#x27;);        map.put(&#x27;3&#x27;, &#x27;E&#x27;); map.put(&#x27;5&#x27;, &#x27;Z&#x27;);        map.put(&#x27;8&#x27;, &#x27;8&#x27;);        while(in.hasNext())&#123;            boolean p = false;            boolean m = true;            String str = in.nextLine();            StringBuilder str2 = new StringBuilder(str);            if(str.equals(str2.reverse().toString()))&#123;                p = true;            &#125;            for(int i = 0; i &lt; str.length(); i++)&#123;                char ch = str.charAt(i);                char ch2 = str.charAt(str.length() - i - 1);                if(!map.containsKey(ch) || map.get(ch) != ch2)&#123;                    m = false;                    break;                &#125;            &#125;            if(p &amp;&amp; m)          System.out.println(str + &quot; -- is a mirrored palindrome.&quot;);            else if(p)     System.out.println(str + &quot; -- is a regular palindrome.&quot;);            else if(m)    System.out.println(str + &quot; -- is a mirrored string.&quot;);            else                System.out.println(str + &quot; -- is not a palindrome.&quot;);            System.out.println(&quot;&quot;);        &#125;    &#125;&#125;","slug":"UVA-401","date":"2025-05-01T12:27:06.000Z","categories_index":"UVa-⭐","tags_index":"Java,UVa","author_index":"三三"},{"id":"4b390c175c6b5ba1f50ee7c6ec90878f","title":"UVa 389 - Basically Speaking 解題紀錄","content":"📝 題目簡介給定一個數字、一個來源進位（base-n）與一個目標進位（base-m），將該數字從來源進位轉換為目標進位，並輸出結果。若轉換後的結果超過 7 個字元，輸出 ERROR。\n\n📌 題目輸入格式每組輸入包含：\n\n一個表示數字的字串 str（最多 7 個字元，可能包含 0-9 與 A-Z）\n來源進位 n（2 ≤ n ≤ 16）\n目標進位 m（2 ≤ m ≤ 16）\n\n\n📌 題目範例輸入1111000 2 101111000 2 162102101 3 102102101 3 1512312 4 21A 15 2ABCD 16 1503 13 10\n📌 題目範例輸出1207817657CAERROR11001D0713\n\n解題思路先換成十進制再換成目標進制\n💻 Java 程式碼實作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.*;public class Main&#123;    public static void main(String[] args)&#123;        Scanner in = new Scanner(System.in);        while(in.hasNext())&#123;            String str = in.next();            int n = in.nextInt();   // base from            int m = in.nextInt();   // base to            int tmp = 0;            // convert to base 10            for(int i = 0; i &lt; str.length(); i++)&#123;                char ch = str.charAt(i);                int digit;                if(ch &lt; &#x27;A&#x27;)&#123; // digit: &#x27;0&#x27;~&#x27;9&#x27;                    digit = ch - &#x27;0&#x27;;                &#125;                else&#123; // letter: &#x27;A&#x27;~&#x27;F&#x27;                    digit = ch - &#x27;A&#x27; + 10;                &#125;                tmp = tmp * n + digit; // 累積轉為十進位            &#125;            // convert to base m            StringBuilder str2 = new StringBuilder();            if(tmp == 0)&#123;                str2.append(&quot;0&quot;);            &#125;            else&#123;                while(tmp &gt; 0)&#123;                    int digit = tmp % m;                    char ch;                    if(digit &gt; 9)&#123;                        ch = (char)(&#x27;A&#x27; + digit - 10);                    &#125;                    else&#123;                        ch = (char)(digit + &#x27;0&#x27;);                    &#125;                    str2.append(ch);                    tmp /= m;                &#125;            &#125;            if(str2.length() &gt; 7)&#123;                System.out.println(&quot;  ERROR&quot;);            &#125;            else&#123;                System.out.printf(&quot;%7s\\n&quot;, str2.reverse());            &#125;        &#125;    &#125;&#125;","slug":"UVA-389","date":"2025-04-29T19:43:21.000Z","categories_index":"UVa-⭐","tags_index":"Java,UVa","author_index":"三三"},{"id":"448899ffc5865887ee582722a0e73a3d","title":"UVa 386 - Perfect Cubes 題目筆記","content":"📝 題目簡介本題要求列出所有符合以下條件的整數組合 (a, b, c, d)：\na³ &#x3D; b³ + c³ + d³\n條件限制如下：\n\n2 ≤ a ≤ 200\n2 ≤ b ≤ c ≤ d &lt; a\n\n\n📌 題目範例輸出Cube &#x3D; 6, Triple &#x3D; (3,4,5)Cube &#x3D; 12, Triple &#x3D; (6,8,10)Cube &#x3D; 18, Triple &#x3D; (2,12,16)Cube &#x3D; 18, Triple &#x3D; (9,12,15)Cube &#x3D; 19, Triple &#x3D; (3,10,18)Cube &#x3D; 20, Triple &#x3D; (7,14,17)Cube &#x3D; 24, Triple &#x3D; (12,16,20)\n\n解題思路直覺、暴力破解\n\n遍歷 a 從 2 到 200\n對於每個 a，計算 a³\n接著三層巢狀迴圈，遍歷 b, c, d：\n條件為 b ≤ c ≤ d &lt; a\n確保不重複排列（例如 (2,3,4) 和 (3,2,4) 都不會重複出現）\n\n\n若 b³ + c³ + d³ == a³，就輸出結果\n\n💻 Java 程式碼實作1234567891011121314151617181920import java.util.*;public class Main&#123;    public static void main(String[] args)&#123;                for (int i = 2; i &lt;= 200; i++)&#123;         // a            int a3 = i*i*i;            for(int j = 2; j &lt; i; j++)&#123;         // b                for(int k = j; k &lt; i; k++)&#123;     // c                    for(int l = k; l &lt; i; l++)&#123; // d                        int tmp = j*j*j + k*k*k + l*l*l;                        if(a3 == tmp)&#123;                            System.out.printf(&quot;Cube = %d, Triple = (%d,%d,%d)\\n&quot;, i, j, k, l);                        &#125;                    &#125;                &#125;                        &#125;          &#125;    &#125;&#125;","slug":"UVA-386","date":"2025-04-29T18:28:19.000Z","categories_index":"UVa-⭐","tags_index":"Java,UVa","author_index":"三三"},{"id":"fdc7f82054e3322894610c08b3e708c6","title":"UVa 382 - Perfection 解題紀錄","content":"已經一年多沒考過CPE了，最近發現距離大三最後一次CPE只剩20天，突然一股幹勁想把分數衝高一點，偷偷立個Flag要堅持天天刷三題，嗚嗚這真的很難，大一的時候也就一天一題，我的程式能力太差了，加上現在大三事情真的多到爆炸:(好了廢話結束 加油三三!!! \n📝 題目簡介UVA 382 的任務是判斷輸入的整數是否為：\n\nPERFECT（完全數）：所有真因數的總和等於該數\nABUNDANT（盈數）：總和大於該數\nDEFICIENT（虧數）：總和小於該數\n\n\n\n\n\n\n\n\n\n\n真因數：除了自己以外的正整數因數（包含 1）\n\n📌 題目範例輸入15 28 6 56 60000 22 496 0\n📌 題目範例輸出PERFECTION OUTPUT15 DEFICIENT28 PERFECT6 PERFECT56 ABUNDANT60000 ABUNDANT22 DEFICIENT496 PERFECTEND OF OUTPUT\n\n解題思路直覺做法\n\n連續讀入整數 n，直到遇到 0 為止（作為結束標記）\n對每個 n：\n計算所有真因數（小於 n 且可整除 n）\n將真因數加總\n根據總和結果分類為：\nPERFECT\nABUNDANT\nDEFICIENT\n\n\n\n\n使用格式化輸出對齊（%5d）\n\n\n💻 Java 實作程式碼12345678910111213141516171819202122232425262728293031323334import java.util.*;public class Main&#123;    public static void main(String[] args)&#123;        Scanner in = new Scanner(System.in);        int n = in.nextInt();        System.out.println(&quot;PERFECTION OUTPUT&quot;);        while(n != 0)&#123;            int k = n / 2;            int sum = 1;            for(int i = 2; i &lt;= k; i++)&#123;                if(n % i == 0)&#123;                    sum += i;                &#125;            &#125;            if(sum == n &amp;&amp; n != 1)&#123;                System.out.printf(&quot;%5d  PERFECT&quot;, n);            &#125;            else if(sum &gt; n)&#123;                System.out.printf(&quot;%5d  ABUNDANT&quot;, n);            &#125;            else&#123;                System.out.printf(&quot;%5d  DEFICIENT&quot;, n);            &#125;            System.out.println(&quot;&quot;);            n = in.nextInt();        &#125;        System.out.println(&quot;END OF OUTPUT&quot;);    &#125;&#125;","slug":"UVA_382","date":"2025-04-29T17:59:40.000Z","categories_index":"UVa-⭐","tags_index":"Java,UVa","author_index":"三三"}]